import fs from "fs/promises";

let cachedCodebook = null;

const STOPWORDS = new Set([
  "the", "and", "for", "with", "that", "this", "from", "into", "about", "have",
  "has", "had", "was", "were", "are", "is", "a", "an", "to", "of", "in", "on",
  "at", "it", "as", "be", "by", "or", "if", "but", "not", "can", "could", "would",
  "should", "very", "really", "just", "more", "most", "some", "any", "all", "than",
  "then", "their", "there", "they", "them", "you", "your", "our", "ours", "we", "i",
  "he", "she", "his", "her", "its", "my", "me", "us"
]);

const CATEGORY_HINTS = {
  "instructional clarity": [
    "clear", "clarity", "explain", "explained", "explaining", "understand",
    "understanding", "confusing", "details", "detailed", "pace", "fast", "slow",
    "organized", "structure", "examples", "demonstration", "lesson", "lessons",
    "concept", "concepts", "technical", "vocabulary", "quick", "quickly",
    "big picture", "figure out", "confidence", "confident", "more confident"
  ],
  "professor demeanor": [
    "kind", "nice", "caring", "passion", "passionate", "friendly", "approachable",
    "supportive", "knowledgeable", "expert", "enthusiastic", "lecturer",
    "honest", "honesty", "composed", "calm", "patient", "patience", "authentic",
    "inspiring", "inspiration", "character", "role model", "straightforward",
    "direct", "honest feedback", "didn't sugarcoat", "did not sugarcoat", "tougher"
  ],
  "course difficulty": [
    "hard", "difficult", "challenging", "easy", "complex", "advanced", "beginner"
  ],
  "student engagement": [
    "engaging", "engagement", "interactive", "participation", "discussion",
    "involved", "attention", "boring", "critical", "critically", "think",
    "reflection", "reflect", "motivation", "motivated", "confidence", "grew",
    "growth", "learned", "learn", "high-stakes", "high stakes", "ready"
  ],
  "feedback and responsiveness": [
    "responsive", "response", "questions", "question", "help", "office", "hours",
    "support", "reply", "email", "ta", "clarification", "one-on-one", "1-on-1",
    "available", "availability", "guidance", "mentor", "mentoring", "check-in",
    "checkin", "clarify"
  ],
  "use of technology": [
    "tool", "tools", "technology", "software", "platform", "canvas", "zoom",
    "video", "recorded", "online", "resource", "resources", "lab"
  ],
  "grading and assessment": [
    "grade", "grading", "rubric", "assessment", "exam", "exams", "test", "tests",
    "quiz", "quizzes", "points", "credit", "fair"
  ],
  "course content relevance": [
    "real-world", "real", "world", "practical", "applicable", "application",
    "relevant", "industry", "career", "job", "workplace", "life", "impact",
    "changed how i think", "rethink", "the why", "why of what we're doing",
    "people behind the systems", "carry that forward"
  ],
  "workload and time management": [
    "workload", "time", "deadline", "deadlines", "project", "projects", "heavy",
    "busy", "manageable", "schedule", "weekly"
  ],
  "spiritual and ethical integration": [
    "spiritual", "ethical", "ethics", "moral", "values", "integrity", "gospel",
    "faith"
  ],
};

// Concept-level patterns to catch meaning even when exact keywords vary.
// Each inner array is a group of stems/phrases; matching one item in each group
// strongly suggests the category.
const CATEGORY_CONCEPT_PATTERNS = {
  "instructional clarity": [
    [["confiden"], ["discuss", "talk"], ["cyber", "security", "cybersecurity"]],
    [["understand", "clar"], ["why", "how"]],
  ],
  "professor demeanor": [
    [["sugarcoat", "sugarco"], ["appreciat", "respect"]],
    [["honest", "direct", "straightforward"], ["tougher", "resilien"]],
  ],
  "student engagement": [
    [["challenge", "challeng"], ["high", "stake"]],
    [["high", "stake"], ["ready", "prepar"]],
  ],
  "course content relevance": [
    [["connect"], ["why"], ["people", "system"]],
    [["carry"], ["forward"]],
  ],
};

function stemToken(token) {
  let t = String(token || "").toLowerCase();
  if (t.length > 5 && t.endsWith("ing")) t = t.slice(0, -3);
  else if (t.length > 4 && t.endsWith("ed")) t = t.slice(0, -2);
  else if (t.length > 4 && t.endsWith("es")) t = t.slice(0, -2);
  else if (t.length > 3 && t.endsWith("s")) t = t.slice(0, -1);
  if (t.length > 4 && t.endsWith("ly")) t = t.slice(0, -2);
  return t;
}

function normalizeTokens(text) {
  return String(text || "")
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, " ")
    .split(/\s+/)
    .map((w) => stemToken(w.trim()))
    .filter((w) => w.length >= 3 && !STOPWORDS.has(w));
}

function categoryConceptScore(text, tokenSet, category) {
  const patterns = CATEGORY_CONCEPT_PATTERNS[category] || [];
  let score = 0;
  for (const groups of patterns) {
    let matchedGroups = 0;
    for (const group of groups) {
      const groupMatch = group.some((rawTerm) => {
        const term = stemToken(rawTerm);
        if (!term) return false;
        if (term.includes(" ")) {
          return text.includes(term);
        }
        for (const token of tokenSet) {
          if (token === term || token.startsWith(term) || term.startsWith(token)) {
            return true;
          }
        }
        return false;
      });
      if (groupMatch) matchedGroups++;
    }
    if (matchedGroups === groups.length) {
      score += 3;
    }
  }
  return score;
}

/**
 * Loads the codebook JSON file once and caches it.
 */
export async function loadCodebook() {
  if (!cachedCodebook) {
    const raw = await fs.readFile("standardized_codebook.json", "utf8");
    cachedCodebook = JSON.parse(raw);
  }
  return cachedCodebook;
}

/**
 * Matches comment text against codebook keywords.
 * Returns an array of categories that matched.
 */
export async function matchThemes(commentText) {
  const codebook = await loadCodebook();
  const text = String(commentText || "").toLowerCase();
  const commentTokens = new Set(normalizeTokens(text));
  const matchedThemes = [];
  const scoredThemes = [];

  for (const entry of codebook) {
    const examples = Array.isArray(entry.examples) ? entry.examples : [];
    const definition = String(entry.definition || "");

    let exactMatch = false;
    for (const phrase of examples) {
      const normalizedPhrase = String(phrase || "").toLowerCase().trim();
      if (normalizedPhrase && text.includes(normalizedPhrase)) {
        exactMatch = true;
        matchedThemes.push(entry.category);
        break;
      }
    }

    if (exactMatch) continue;

    const keywordSource = `${definition} ${examples.join(" ")} ${entry.category || ""}`;
    const categoryTokens = normalizeTokens(keywordSource);
    if (categoryTokens.length === 0) continue;

    let overlap = 0;
    for (const token of categoryTokens) {
      if (commentTokens.has(token)) overlap++;
    }

    if (overlap > 0) {
      scoredThemes.push({ category: entry.category, score: overlap });
    }
  }

  if (matchedThemes.length < 3 && scoredThemes.length > 0) {
    scoredThemes.sort((a, b) => b.score - a.score);
    for (const item of scoredThemes) {
      if (matchedThemes.length >= 3) break;
      if (!matchedThemes.includes(item.category) && item.score >= 2) {
        matchedThemes.push(item.category);
      }
    }
  }

  // Extra deterministic hints improve coverage when example phrases are sparse.
    if (matchedThemes.length < 3) {
      const hintScores = [];
      for (const entry of codebook) {
        const category = entry.category;
        const hints = CATEGORY_HINTS[category] || [];
      if (hints.length === 0) continue;
      let score = 0;
      for (const hint of hints) {
        const normalizedHint = String(hint || "").toLowerCase();
        if (!normalizedHint) continue;
        if (normalizedHint.includes(" ")) {
          if (text.includes(normalizedHint)) score += 2;
          continue;
        }
        if (commentTokens.has(stemToken(normalizedHint))) score += 1;
      }
        if (score > 0) {
          score += categoryConceptScore(text, commentTokens, category);
          hintScores.push({ category, score });
        } else {
          const conceptOnlyScore = categoryConceptScore(text, commentTokens, category);
          if (conceptOnlyScore > 0) {
            hintScores.push({ category, score: conceptOnlyScore });
          }
        }
      }
    hintScores.sort((a, b) => b.score - a.score);
    for (const item of hintScores) {
      if (matchedThemes.length >= 3) break;
      if (!matchedThemes.includes(item.category)) {
        matchedThemes.push(item.category);
      }
    }
  }

  // If nothing met threshold, still return the best lexical match (if any)
  // so downstream summary/visualization doesn't become empty for most comments.
  if (matchedThemes.length === 0 && scoredThemes.length > 0) {
    scoredThemes.sort((a, b) => b.score - a.score);
    matchedThemes.push(scoredThemes[0].category);
  }

  return [...new Set(matchedThemes)].slice(0, 3);
}
