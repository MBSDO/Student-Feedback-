console.log("Loading Comment Module");
import { DBEntity } from "./dbentity.mjs";
import express from "express";
import { db } from "./db.mjs";
import { Report } from "./report.mjs";
import { matchThemes } from "./codebook.mjs";
import crypto from "crypto";
console.log("Imported modules");
import { OpenAISendBatch } from "./openai.mjs";
import { readFile } from "fs/promises";
import { requireAuth, validateId, safeErrorResponse } from "./security.mjs";

const codebook = JSON.parse(
  await readFile(new URL("../standardized_codebook.json", import.meta.url)),
);

const commentLogPrefix = "[comment]";
function logComment(level, event, data = {}) {
  const payload = {
    ts: new Date().toISOString(),
    event,
    ...data,
  };
  if (level === "error") {
    console.error(commentLogPrefix, JSON.stringify(payload));
  } else if (level === "warn") {
    console.warn(commentLogPrefix, JSON.stringify(payload));
  } else {
    console.log(commentLogPrefix, JSON.stringify(payload));
  }
}

export class Comment extends DBEntity {
  constructor() {
    super("comments", "cid");
    // Note: categories should be stored in comments_settings table
    // Don't set this.categories here to ensure SaveSettings saves to settings table
  }
  static estimateTokens(text) {
    const wordCount = text.trim().split(/\s+/).length;
    return Math.ceil(wordCount / 0.75);
  }

  async ProcessBatch(comments) {
    const MAX_TOKENS = 11000; // Safe for gpt-3.5-turbo
    const BATCH_OVERHEAD = 1000; // Prompt formatting, codebook, etc.

    const results = [];
    let currentBatch = [];
    let currentTokenCount = BATCH_OVERHEAD;

    for (const comment of comments) {
      const commentTokens = Comment.estimateTokens(comment.text);

      if (
        currentTokenCount + commentTokens > MAX_TOKENS &&
        currentBatch.length > 0
      ) {
        // Send current batch
        await this.processCommentBatch(currentBatch, results);
        // Start new batch
        currentBatch = [];
        currentTokenCount = BATCH_OVERHEAD;
      }

      currentBatch.push(comment);
      currentTokenCount += commentTokens;
    }

    // Send last batch
    if (currentBatch.length > 0) {
      await this.processCommentBatch(currentBatch, results);
    }

    return results;
  }

  async processCommentBatch(commentBatch, results) {
    const batch = commentBatch.map((c) => ({ text: c.text }));
    const response = await OpenAISendBatch(batch, codebook);

    if (!response) {
      console.warn("‚ö†Ô∏è Skipping batch due to null response.");
      return;
    }

    for (let i = 0; i < commentBatch.length; i++) {
      const comment = commentBatch[i];
      const key = `Comment ${i + 1}`;
      const llmThemes = response[key] || [];

      const codebookThemes = await matchThemes(comment.text);
      const allThemes = [...new Set([...codebookThemes, ...llmThemes])];

      // Save categories as JSON
      await comment.SaveSettings({
        categories: JSON.stringify(allThemes),
      });

      // Clear other fields using direct SQL to ensure proper NULL handling
      await db.query(
        `UPDATE ${comment.tableName}
         SET sentiment = NULL,
             civility = NULL,
             aims = NULL,
             themes = NULL,
             subject = NULL
         WHERE cid = $1`,
        [comment.cid],
      );

      await comment.Get(comment.cid);
      results.push(comment);
    }
  }

  async Process() {
    return new Promise(async (resolve, reject) => {
      try {
        // Step 1: Match themes using codebook
        const codebookThemes = await matchThemes(this.text);
        // console.log(`üîç [DEBUG] Codebook themes for comment ${this.cid}:`, codebookThemes);

        // Step 2: Run OpenAI for enrichment (using batch function with single comment)
        const batch = [{ text: this.text }];
        const response = await OpenAISendBatch(batch, codebook);

        // üöë AI unavailable ‚Äî do NOT fail
        if (!response) {
          console.warn(
            `‚ö†Ô∏è AI unavailable for comment ${this.cid}. Saving codebook-only themes.`,
          );

          const codebookThemes = await matchThemes(this.text);

          await this.SaveSettings({
            categories: JSON.stringify(codebookThemes),
          });

          return resolve(this); // ‚úÖ EXIT EARLY, NO CRASH
        }

        // Step 3: Extract themes from OpenAI response
        const llmThemes = response["Comment 1"] || [];

        // console.log(`üîç [DEBUG] LLM themes for comment ${this.cid}:`, llmThemes);

        // Step 4: Merge both codebook and LLM themes
        const allThemes = [...new Set([...codebookThemes, ...llmThemes])];
        // console.log(`üîç [DEBUG] Combined themes for comment ${this.cid}:`, allThemes);

        // Step 5: Save to DB - using categories field as JSON
        await this.SaveSettings({
          categories: JSON.stringify(allThemes),
        });

        // Step 6: Clear other fields using direct SQL to ensure proper NULL handling
        await db.query(
          `UPDATE ${this.tableName}
           SET sentiment = NULL,
               civility = NULL,
               aims = NULL,
               themes = NULL,
               subject = NULL
           WHERE cid = $1`,
          [this.cid],
        );

        await this.Get(this.cid);
        resolve(this);
      } catch (error) {
        console.error(
          `‚ùå [ERROR] Failed to process comment ${this.cid}:`,
          error,
        );
        reject(error);
      }
    });
  }

  async Clear() {
    return new Promise(async (resolve, reject) => {
      try {
        // Clear fields in the main table
        await db.query(
          `UPDATE ${this.tableName}
   SET sentiment = NULL,
       civility = NULL,
       aims = NULL,
       themes = NULL,
       subject = NULL,
       categories = NULL
   WHERE cid = $1`,
          [this.cid],
        );

        // Clear any settings
        await this.DeleteSettings();

        await this.Get(this.cid);
        resolve(this);
      } catch (error) {
        reject(error);
      }
    });
  }
  async Create(rid, text) {
    return new Promise(async (resolve, reject) => {
      try {
        if (!text || text.trim() === "") {
          console.warn("‚ö†Ô∏è Skipping empty comment.");
          return resolve(null); // Don't throw ‚Äî just skip
        }

        const results = await db.query(
          `INSERT INTO ${this.tableName} (rid, text) VALUES ($1, $2) RETURNING cid`,
          [rid, text],
        );

        if (!results[0]?.cid) {
          console.warn("‚ö†Ô∏è Inserted comment but no cid returned.");
          return resolve(null); // Also skip if insert didn't return ID
        }

        await this.Get(results[0].cid);
        resolve(this);
      } catch (error) {
        reject(error);
      }
    });
  }
}

export const CommentRouter = express.Router();
/*
CommentRouter.post('/create', async (req, res) => {
    try {
        if(req.session.user === undefined) {
            res.status(403).json({ error: 'Permission denied.' });
            return;
        }
        let comment = new Comment();
        await comment.Create(req.session.user.uid, req.body);
        res.json(comment);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});
*/
console.log("Registering generic route");
CommentRouter.post("/:cid/*action", requireAuth, async (req, res, next) => {
  try {
    req.commentTraceId = req.get("X-Client-Trace-Id") || crypto.randomUUID();
    req.commentActionStart = Date.now();
    res.set("X-Comment-Trace-Id", req.commentTraceId);

    const cid = validateId(req.params.cid);
    if (!cid) {
      return res.status(400).json({ error: "Invalid comment ID" });
    }
    
    req.comment = new Comment();
    await req.comment.Get(cid);
    req.report = new Report();
    await req.report.Get(req.comment.rid);
    
    // Verify ownership
    if (req.report.uid !== req.session.user.uid) {
      return res.status(403).json({ error: "Permission denied." });
    }

    logComment("info", "route_verified", {
      trace_id: req.commentTraceId,
      uid: req.session.user.uid,
      cid,
      rid: req.comment.rid,
      action: req.params.action,
    });
    next();
  } catch (error) {
    logComment("error", "route_failed", {
      trace_id: req.commentTraceId || null,
      error: error?.message || "Unknown error",
      stack: error?.stack || null,
    });
    const errorResponse = safeErrorResponse(error, process.env.NODE_ENV === "development");
    res.status(500).json(errorResponse);
  }
});

console.log("Registering viewer");
CommentRouter.post("/:cid/view", async (req, res) => {
  try {
    res.json(req.comment);
  } catch (error) {
    console.error("Error viewing comment:", error);
    const errorResponse = safeErrorResponse(error, process.env.NODE_ENV === "development");
    res.status(500).json(errorResponse);
  }
});

console.log("Registering delete");
CommentRouter.post("/:cid/delete", async (req, res) => {
  try {
    await req.comment.Delete();
    res.json({ success: true });
  } catch (error) {
    console.error("Error deleting comment:", error);
    const errorResponse = safeErrorResponse(error, process.env.NODE_ENV === "development");
    res.status(500).json(errorResponse);
  }
});

CommentRouter.post("/:cid/process", async (req, res) => {
  const startedAt = Date.now();
  try {
    logComment("info", "process_started", {
      trace_id: req.commentTraceId || null,
      uid: req.session?.user?.uid || null,
      cid: req.comment?.cid || null,
      rid: req.comment?.rid || null,
    });
    await req.comment.Process();
    const durationMs = Date.now() - startedAt;
    logComment("info", "process_completed", {
      trace_id: req.commentTraceId || null,
      uid: req.session?.user?.uid || null,
      cid: req.comment?.cid || null,
      rid: req.comment?.rid || null,
      duration_ms: durationMs,
    });
    res.json({
      ...req.comment,
      trace_id: req.commentTraceId || null,
      duration_ms: durationMs,
    });
  } catch (error) {
    const durationMs = Date.now() - startedAt;
    logComment("error", "process_failed", {
      trace_id: req.commentTraceId || null,
      uid: req.session?.user?.uid || null,
      cid: req.comment?.cid || null,
      rid: req.comment?.rid || null,
      duration_ms: durationMs,
      error: error?.message || "Unknown error",
      stack: error?.stack || null,
    });
    const errorResponse = safeErrorResponse(error, process.env.NODE_ENV === "development");
    res.status(500).json(errorResponse);
  }
});

CommentRouter.post("/:cid/clear", async (req, res) => {
  try {
    await req.comment.Clear();
    res.json(req.comment);
  } catch (error) {
    console.error("Error clearing comment:", error);
    const errorResponse = safeErrorResponse(error, process.env.NODE_ENV === "development");
    res.status(500).json(errorResponse);
  }
});
