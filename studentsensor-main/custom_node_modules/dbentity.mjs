console.log("Loading DBEntity Module");
import { db, dbConfig } from "../custom_node_modules/db.mjs";

export class DBEntity {
  fully_loaded = false;

  constructor(tableName, idName) {
    this.tableName = tableName;
    this.tableSettingsName = tableName + "_settings";
    this.idName = idName;
    this.exists = false;
    this.type = this.constructor.name;
  }

  async Create() {
    const sql = `INSERT INTO ${this.tableName} DEFAULT VALUES RETURNING *`;
    const rows = await db.query(sql);
    await this.Get(rows[0][this.idName]);
    return this;
  }

  async Can(user, verb) {
    if (!user?.id) return false;
    if (this.uid !== undefined && this.uid === user.id) return true;
    if (await CheckRole(user, "admin")) return true;
    return false;
  }

  async Delete() {
    await db.query(`DELETE FROM ${this.tableName} WHERE ${this.idName} = $1`, [
      this.id,
    ]);
    await db.query(
      `DELETE FROM ${this.tableSettingsName} WHERE ${this.idName} = $1`,
      [this.id]
    );
    return true;
  }

  async Get(id) {
    if (id === undefined || id === null || isNaN(Number(id))) {
      throw new Error(`❌ Invalid ID passed to Get(): ${id}`);
    }

    const sql = `SELECT * FROM ${this.tableName} WHERE ${this.idName} = $1 LIMIT 1`;
    const rows = await db.query(sql, [id]);

    if (rows.length === 0) {
      throw new Error(`❌ No results found for ${this.tableName} ID: ${id}`);
    }

    const row = rows[0];
    this.id = row[this.idName];
    this.exists = true;
    for (let key in row) {
      this[key] = row[key];
    }
    return this;
  }

  async GetIDFromSetting(name, value, include_core = true) {
    if (include_core) {
      const checkSql = `
                SELECT column_name FROM information_schema.columns
                WHERE table_schema = 'public' AND table_name = $1 AND column_name = $2
                LIMIT 1
            `;
      const found = await db.query(checkSql, [this.tableName, name]);
      if (found.length > 0) {
        const coreSql = `
                    SELECT ${this.idName} FROM ${this.tableName}
                    WHERE ${name} = $1 LIMIT 1
                `;
        const rows = await db.query(coreSql, [value]);
        if (rows.length > 0) return rows[0][this.idName];
      }
    }

    const settingSql = `
            SELECT ${this.idName} FROM ${this.tableSettingsName}
            WHERE name = $1 AND value = $2 LIMIT 1
        `;
    const rows = await db.query(settingSql, [name, value]);
    if (rows.length > 0) return rows[0][this.idName];
    return null;
  }

  async GetSettings(id = null) {
    if (!this.id && id !== null) await this.Get(id);

    const sql = `
            SELECT name, value FROM ${this.tableSettingsName}
            WHERE ${this.idName} = $1
        `;
    const rows = await db.query(sql, [this.id]);

    this.settings = {};
    for (let row of rows) {
      this.settings[row.name] = row.value;
    }
    this.fully_loaded = true;
    return this;
  }

  async GetSetting(name, rebuild = false) {
    if (this.settings?.[name] && !rebuild) return this.settings[name];

    const sql = `
            SELECT value FROM ${this.tableSettingsName}
            WHERE ${this.idName} = $1 AND name = $2 LIMIT 1
        `;
    const rows = await db.query(sql, [this.id, name]);

    if (!this.settings) this.settings = {};
    if (rows.length > 0) {
      this.settings[name] = rows[0].value;
      return rows[0].value;
    }
    return null;
  }

  async SaveSettings(settings, admin = false) {
    for (let key in settings) {
      await this.SaveSetting(key, settings[key], admin);
    }
    return this;
  }

  async SaveSetting(name, value, admin = false) {
    if (!this.exists) return;

    const disallowed = [
      "id",
      this.idName,
      "exists",
      "tableName",
      "idName",
      "type",
      "credits",
    ];
    if (disallowed.includes(name) && !admin) {
      console.log(`❌ Permission denied changing ${name}`);
      return;
    }

    if (typeof value === "object" && value !== null) {
      await this.SaveSetting(name, "{}");
      for (let key in value) {
        await this.SaveSetting(`${name}_${key}`, value[key]);
      }
      return;
    }

    if (this[name] !== undefined) {
      this[name] = value;
      const sql = `
                UPDATE ${this.tableName}
                SET ${name} = $1
                WHERE ${this.idName} = $2
            `;
      await db.query(sql, [value, this.id]);
      return;
    } else {
      await this.GetSetting(name);

      if (value == null) {
        if (this.settings[name] !== undefined) delete this.settings[name];
        const delSql = `
                    DELETE FROM ${this.tableSettingsName}
                    WHERE ${this.idName} = $1 AND name = $2
                `;
        await db.query(delSql, [this.id, name]);
        return;
      }

      if (!this.settings) this.settings = {};
      this.settings[name] = value;

      const upsertSql = `
                INSERT INTO ${this.tableSettingsName} (${this.idName}, name, value)
                VALUES ($1, $2, $3)
                ON CONFLICT (${this.idName}, name)
                DO UPDATE SET value = EXCLUDED.value
            `;
      await db.query(upsertSql, [this.id, name, value]);

      if (name === "generated_response_text") {
        const json = JSON.parse(value.replace(/\n/g, ""));
        for (let key in json) {
          await this.SaveSetting(key, json[key]);
        }
      }
    }
  }

  async DeleteSettings() {
    const sql = `DELETE FROM ${this.tableSettingsName} WHERE ${this.idName} = $1`;
    await db.query(sql, [this.id]);
    return this;
  }

  async DeleteSetting(name) {
    const sql = `
            DELETE FROM ${this.tableSettingsName}
            WHERE ${this.idName} = $1 AND name = $2
        `;
    await db.query(sql, [this.id, name]);
    return;
  }
}
