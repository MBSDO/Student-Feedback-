import express from "express";
import https from "https";
import dotenv from "dotenv";
import { fileURLToPath } from "url";
import { dirname, resolve } from "path";

import { User } from "./user.mjs";

dotenv.config(); // Load .env

// Compute current directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Initialize router
export const GoogleAuthRouter = express.Router();

/**
 * Helper: Safe JSON parse
 */
function safeJsonParse(text) {
  try {
    return { ok: true, value: JSON.parse(text) };
  } catch (err) {
    return { ok: false, error: err, raw: text };
  }
}

/**
 * Exchange authorization code for token (access_token + id_token)
 */
async function CheckToken(code, scope, redirect_uri) {
  const requestData = JSON.stringify({
    grant_type: "authorization_code",
    code: code,
    client_id: process.env.GOOGLE_CLIENT_ID,
    client_secret: process.env.GOOGLE_CLIENT_SECRET,
    redirect_uri: redirect_uri,
    scope: scope,
  });

  const options = {
    hostname: "oauth2.googleapis.com",
    port: 443,
    path: "/token",
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Content-Length": Buffer.byteLength(requestData),
    },
  };

  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      let data = "";
      res.on("data", (chunk) => (data += chunk));
      res.on("end", () => {
        const parsed = safeJsonParse(data);
        if (!parsed.ok) {
          return reject({
            status: "error",
            error: "Token endpoint returned invalid JSON",
            details: parsed.raw?.slice?.(0, 500),
          });
        }

        const response = parsed.value;

        // If Google returns an error object, treat as failure
        if (response.error) {
          return reject({
            status: "error",
            error: response.error,
            error_description: response.error_description,
          });
        }

        // Success
        response.status = "success";
        resolve(response);
      });
    });

    req.on("error", (error) => reject({ status: "error", error }));

    req.setTimeout(5000, () => {
      reject({
        status: "error",
        error: "Connection timeout: Unable to connect to oauth2.googleapis.com",
      });
    });

    req.write(requestData);
    req.end();
  });
}

/**
 * Fetch Google account info using OpenID Connect userinfo endpoint.
 * This does NOT require enabling Google People API.
 *
 * Returns an object like:
 * {
 *   sub: "123...",
 *   email: "...",
 *   email_verified: true,
 *   name: "...",
 *   given_name: "...",
 *   family_name: "...",
 *   picture: "..."
 * }
 */
async function GetAccountData(accessToken) {
  const options = {
    hostname: "openidconnect.googleapis.com",
    port: 443,
    path: "/v1/userinfo",
    method: "GET",
    headers: {
      Authorization: "Bearer " + accessToken,
    },
  };

  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      let data = "";
      res.on("data", (chunk) => (data += chunk));
      res.on("end", () => {
        const parsed = safeJsonParse(data);
        if (!parsed.ok) {
          return reject({
            status: "error",
            error: "userinfo endpoint returned invalid JSON",
            details: parsed.raw?.slice?.(0, 500),
          });
        }

        const response = parsed.value;

        // userinfo may return an error
        if (response.error) {
          return reject({
            status: "error",
            error: response.error,
            error_description: response.error_description,
          });
        }

        response.status = "success";
        resolve(response);
      });
    });

    req.on("error", (error) => reject({ status: "error", error }));

    req.setTimeout(5000, () => {
      reject({
        status: "error",
        error:
          "Connection timeout: Unable to connect to openidconnect.googleapis.com",
      });
    });

    req.end();
  });
}

/**
 * Handle Google OAuth2 callback
 *
 * Expected callback route:
 *   /auth/google/callback
 * and your router is likely mounted at:
 *   /auth/google
 * so this file handles:
 *   GET /auth/google/callback
 */
GoogleAuthRouter.get("/callback", async (req, res) => {
  try {
    // Validate OAuth code
    const code = req.query.code;
    if (!code || typeof code !== "string" || code.length > 500) {
      console.error("Invalid OAuth code received");
      return res.sendFile(resolve(__dirname, "../public/pages/403.html"));
    }
    
    // 1) Exchange code for tokens
    const tokenResponse = await CheckToken(
      code,
      req.query.scope,
      process.env.GOOGLE_CALLBACK_URL,
    );

    if (
      tokenResponse.status === "success" &&
      tokenResponse.access_token &&
      tokenResponse.expires_in > 0
    ) {
      // 2) Get user profile from OpenID userinfo
      const accountData = await GetAccountData(tokenResponse.access_token);

      // IMPORTANT: OpenID identity key is `sub`
      if (accountData?.sub) {
        // Find existing user by stable Google subject
        let uid = await new User().GetIDFromSetting(
          "google_sub",
          accountData.sub,
        );

        let user;
        if (uid !== null) {
          user = await new User().Get(parseInt(uid));
        } else {
          user = await new User().Create();

          await user.SaveSetting("google_sub", accountData.sub);
          await user.SaveSetting("name", accountData.name || "Unnamed");

          if (accountData.email) {
            await user.SaveSetting("google_email", accountData.email);
            await user.SaveSetting("email", accountData.email);
          }
        }

        // Log in the user
        req.session.loggedin = true;
        user.Mask();
        await user.GetSettings();
        req.session.user = user;

        console.log("ðŸ‘¤ Account Data (userinfo):", accountData);
        console.log("âœ… User session established:", req.session.user?.uid);
        console.log("Google callback req.query:", req.query);

        return res.redirect("/");
      } else {
        console.error(
          "OAuth profile fetch succeeded but missing `sub`:",
          accountData,
        );
      }
    } else {
      console.error(
        "Token exchange did not return a usable access token:",
        tokenResponse,
      );
    }

    // If something failed
    return res.sendFile(resolve(__dirname, "../public/pages/403.html"));
  } catch (err) {
    // This will now show the real cause (token error, userinfo error, etc.)
    console.error("GoogleAuth callback error:", err);
    return res.sendFile(resolve(__dirname, "../public/pages/403.html"));
  }
});
