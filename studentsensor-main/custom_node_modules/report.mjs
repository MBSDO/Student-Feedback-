console.log("üîß report.mjs is executing...");

import express from "express";
import { db } from "./db.mjs";
import path from "path";
import fs from "fs/promises";
import fsSync from "fs";
import crypto from "crypto";
import { spawn } from "child_process";
import { fileURLToPath } from "url";
import { parse } from "csv-parse/sync";
import { Comment } from "./comment.mjs";
import { OpenAIHealthCheck } from "./openai.mjs";
import {
  requireAuth,
  validateId,
  validateText,
  validateCSV,
  sanitizeString,
  safeErrorResponse,
  sanitizeFilePath,
} from "./security.mjs";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ‚úÖ Global in-memory progress tracker with timestamps for ETA calculation
const progressMap = new Map();
const uploadLogPrefix = "[upload]";

function logUpload(level, event, data = {}) {
  const payload = {
    ts: new Date().toISOString(),
    event,
    ...data,
  };
  if (level === "error") {
    console.error(uploadLogPrefix, JSON.stringify(payload));
  } else if (level === "warn") {
    console.warn(uploadLogPrefix, JSON.stringify(payload));
  } else {
    console.log(uploadLogPrefix, JSON.stringify(payload));
  }
}

function parseCategoryList(rawCategories) {
  if (rawCategories === null || rawCategories === undefined) return [];

  if (Array.isArray(rawCategories)) {
    return rawCategories
      .map((item) => String(item ?? "").trim())
      .filter(Boolean);
  }

  if (typeof rawCategories === "string") {
    const trimmed = rawCategories.trim();
    if (!trimmed) return [];
    try {
      const parsed = JSON.parse(trimmed);
      if (Array.isArray(parsed)) {
        return parsed
          .map((item) => String(item ?? "").trim())
          .filter(Boolean);
      }
      if (typeof parsed === "string") {
        return parsed
          .split(",")
          .map((item) => item.trim())
          .filter(Boolean);
      }
    } catch {
      // Not JSON; treat as comma-separated text.
    }
    return trimmed
      .split(",")
      .map((item) => item.trim())
      .filter(Boolean);
  }

  return String(rawCategories)
    .split(",")
    .map((item) => item.trim())
    .filter(Boolean);
}

export class Report {
  constructor() {
    this.tableName = "reports";
    this.primaryKey = "rid";
    this.rid = null;
    this.uid = null;
    this.name = "";
    this.updated = null;
    this.exists = false;
  }

  async Create(uid) {
    const result = await db.query(
      `INSERT INTO ${this.tableName} (uid, name, updated)
       VALUES ($1, $2, NOW())
       RETURNING rid`,
      [uid, this.name || "Untitled Report"]
    );
    await this.Get(result[0].rid);
  }

  async Get(rid) {
    const rows = await db.query(
      `SELECT * FROM ${this.tableName} WHERE ${this.primaryKey} = $1 LIMIT 1`,
      [rid]
    );
    if (rows.length === 0) return false;
    Object.assign(this, rows[0]);
    this.exists = true;
    return true;
  }

  async SaveSettings(settings) {
    for (const key in settings) {
      await db.query(
        `INSERT INTO reports_settings (rid, name, value)
         VALUES ($1, $2, $3)
         ON CONFLICT (rid, name) DO UPDATE SET value = EXCLUDED.value`,
        [this.rid, key, settings[key]]
      );
    }
  }

  async SaveSetting(name, value) {
    await this.SaveSettings({ [name]: value });
  }

  async GetSetting(key) {
    const rows = await db.query(
      `SELECT value FROM reports_settings WHERE rid = $1 AND name = $2 LIMIT 1`,
      [this.rid, key]
    );
    return rows[0]?.value || null;
  }
}

export const ReportRouter = express.Router();

ReportRouter.get("/test-health", (req, res) => {
  res.json({ status: "alive" });
});

ReportRouter.get("/openai/status", requireAuth, async (req, res) => {
  const status = await OpenAIHealthCheck();
  logUpload("info", "openai_status_check", {
    uid: req?.session?.user?.uid || null,
    ...status,
  });
  res.json(status);
});

ReportRouter.get("/list", (req, res, next) => {
  if (req.accepts("html")) {
    return res.sendFile(
      path.resolve(global.__basedir, "public/pages/reports.html")
    );
  }
  return next();
});

ReportRouter.get("/list/data", requireAuth, async (req, res) => {
  try {
    const uid = req.session.user.uid; // Already validated by requireAuth
    const rows = await db.query(
      `SELECT rid, name, updated FROM reports WHERE uid = $1 ORDER BY updated DESC`,
      [uid]
    );
    const commentCounts = await db.query(
      `SELECT rid, COUNT(*) AS comments_count FROM comments GROUP BY rid`
    );
    const countMap = Object.fromEntries(
      commentCounts.map((row) => [row.rid, parseInt(row.comments_count)])
    );
    const result = rows.map((row) => ({
      ...row,
      comments_count: countMap[row.rid] || 0,
    }));
    res.json(result);
  } catch (err) {
    console.error("‚ùå Failed to fetch report list:", err);
    res.status(500).json({ error: "Internal server error" });
  }
});

ReportRouter.get("/create", requireAuth, async (req, res) => {
  try {
    const uid = req.session.user.uid; // Already validated by requireAuth
    const professor = validateText(req.query.professor, 255) || "Unknown Professor";
    const course = validateText(req.query.course, 255) || "Untitled Course";
    const report = new Report();
    report.name = `${professor} ‚Äì ${course}`;
    await report.Create(uid);
    res.json({
      rid: report.rid,
      name: report.name,
      updated: report.updated,
      comments_count: 0,
    });
  } catch (err) {
    res.status(500).json({ error: "Failed to create report" });
  }
});

// ‚úÖ New: Progress polling endpoint with ETA calculation
ReportRouter.get("/progress/:rid", requireAuth, (req, res) => {
  const rid = validateId(req.params.rid);
  if (!rid) {
    return res.status(400).json({ error: "Invalid report ID" });
  }
  
  // Verify user owns this report
  // Note: This is a simple check - in production, verify ownership from DB
  const progress = progressMap.get(rid);
  if (progress) {
    const response = { ...progress };
    
    // Calculate ETA if we have enough data
    if (progress.startTime && progress.percent > 5 && progress.percent < 100) {
      const elapsed = Date.now() - progress.startTime;
      const rate = progress.percent / elapsed; // percent per millisecond
      const remaining = 100 - progress.percent;
      const estimatedRemaining = remaining / rate; // milliseconds
      response.eta = Math.max(0, Math.round(estimatedRemaining / 1000)); // seconds
    } else {
      response.eta = null;
    }
    
    res.json(response);
  } else {
    res.json({ percent: 0, message: "Initializing...", state: "initializing", eta: null });
  }
});

ReportRouter.all("/:rid/view", requireAuth, async (req, res) => {
  try {
    const rid = validateId(req.params.rid);
    if (!rid) {
      return res.status(400).json({ error: "Invalid report ID" });
    }
    
    const report = new Report();
    const found = await report.Get(rid);
    if (!found) return res.status(404).json({ error: "Report not found" });
    
    // Verify ownership
    if (report.uid !== req.session.user.uid) {
      return res.status(403).json({ error: "Access denied" });
    }

    // Fetch the summary text from settings
    const summary_text = await report.GetSetting("summary_text");
    const theme_summary_json = await report.GetSetting("themes_summary_json");

    // Add summary_text to the response
    const reportData = {
      ...report,
      summary_text,
      theme_summary: (() => {
        try {
          const parsed = JSON.parse(theme_summary_json || "{}");
          return parsed && typeof parsed === "object" ? parsed : {};
        } catch {
          return {};
        }
      })(),
    };

    res.json(reportData);
  } catch (err) {
    res.status(500).json({ error: "Internal server error" });
  }
});

ReportRouter.get("/:rid/comments", requireAuth, async (req, res) => {
  try {
    const rid = validateId(req.params.rid);
    if (!rid) {
      return res.status(400).json({ error: "Invalid report ID" });
    }
    
    // Verify ownership
    const reportCheck = await db.query(
      `SELECT uid FROM reports WHERE rid = $1 LIMIT 1`,
      [rid]
    );
    if (reportCheck.length === 0) {
      return res.status(404).json({ error: "Report not found" });
    }
    if (reportCheck[0].uid !== req.session.user.uid) {
      return res.status(403).json({ error: "Access denied" });
    }
    
    const rows = await db.query(
      `SELECT * FROM comments WHERE rid = $1 ORDER BY cid ASC`,
      [rid]
    );
    res.json(rows);
  } catch (err) {
    console.error("Error fetching comments:", err);
    res.status(500).json({ error: "Internal server error" });
  }
});

async function processUploadInBackground({
  traceId,
  uid,
  report,
  comments,
  pid,
  validatedCourseCode,
  validatedSemester,
  csv_hash,
  csv_text,
  codebook_json,
  recoded_output_json,
}) {
  const startTime = Date.now();
  logUpload("info", "pipeline_started", {
    trace_id: traceId,
    uid,
    rid: report.rid,
    comments_count: comments.length,
  });

  try {
    logUpload("info", "stage_reading_file", {
      trace_id: traceId,
      rid: report.rid,
    });
    progressMap.set(report.rid, {
      trace_id: traceId,
      percent: 5,
      message: "Reading file...",
      state: "reading_file",
      startTime,
    });

    const totalComments = comments.length;
    const safeTotalComments = Math.max(totalComments, 1);
    progressMap.set(report.rid, {
      trace_id: traceId,
      percent: 10,
      message: `Saving ${totalComments} comments to database...`,
      state: "saving_comments",
      startTime,
    });

    let savedCount = 0;
    logUpload("info", "stage_saving_comments_started", {
      trace_id: traceId,
      rid: report.rid,
      total_comments: totalComments,
    });
    for (const text of comments) {
      const comment = new Comment();
      try {
        await comment.Create(report.rid, text);
        savedCount++;
        if (savedCount % 10 === 0 || savedCount === totalComments) {
          const commentProgress =
            10 + Math.floor((savedCount / safeTotalComments) * 15);
          progressMap.set(report.rid, {
            trace_id: traceId,
            percent: commentProgress,
            message: `Saving comments... (${savedCount}/${totalComments})`,
            state: "saving_comments",
            startTime,
          });
        }
      } catch (err) {
        console.warn("‚ö†Ô∏è Failed to insert comment:", err.message);
      }
    }

    progressMap.set(report.rid, {
      trace_id: traceId,
      percent: 25,
      message: "Writing metadata...",
      state: "writing_metadata",
      startTime,
    });

    await db.query(
      `UPDATE reports SET pid = $1, course_code = $2, semester = $3, csv_hash = $4 WHERE rid = $5`,
      [pid, validatedCourseCode, validatedSemester, csv_hash, report.rid]
    );
    logUpload("info", "stage_metadata_saved", {
      trace_id: traceId,
      rid: report.rid,
      saved_comments: savedCount,
      total_comments: totalComments,
    });

    progressMap.set(report.rid, {
      trace_id: traceId,
      percent: 30,
      message: "Comparing comments with codebook...",
      state: "comparing_codebook",
      startTime,
    });

    if (!fsSync.existsSync(path.resolve(global.__basedir, "tmp"))) {
      fsSync.mkdirSync(path.resolve(global.__basedir, "tmp"));
    }

    const sanitizedFileName = sanitizeFilePath(`report_${report.rid}.csv`);
    if (!sanitizedFileName) {
      throw new Error("Invalid file name");
    }

    const tempPath = path.resolve(global.__basedir, "tmp", sanitizedFileName);
    if (!tempPath.startsWith(path.resolve(global.__basedir, "tmp"))) {
      throw new Error("Invalid file path");
    }
    await fs.writeFile(tempPath, csv_text);
    logUpload("info", "stage_temp_csv_written", {
      trace_id: traceId,
      rid: report.rid,
      temp_path: tempPath,
    });

    console.log(
      `üîç [DEBUG] Processing categories for all comments in report ${report.rid}`
    );
    const commentRows = await db.query(
      "SELECT cid, text FROM comments WHERE rid = $1",
      [report.rid]
    );
    logUpload("info", "stage_comment_rows_loaded", {
      trace_id: traceId,
      rid: report.rid,
      rows: commentRows.length,
    });

    const totalToProcess = commentRows.length;
    const safeTotalToProcess = Math.max(totalToProcess, 1);
    let processedCount = 0;
    let failedCount = 0;
    let loadFailedCount = 0;

    progressMap.set(report.rid, {
      trace_id: traceId,
      percent: 35,
      message: `Sending comments to OpenAI for analysis... (0/${totalToProcess})`,
      state: "sending_openai",
      startTime,
    });

    const commentEntities = [];
    for (const row of commentRows) {
      const comment = new Comment();
      try {
        await comment.Get(row.cid);
        commentEntities.push(comment);
      } catch (err) {
        console.warn(
          `‚ö†Ô∏è Failed to load comment ${row.cid} for batch processing:`,
          err.message
        );
        loadFailedCount++;
      }
    }

    const batchProcessor = new Comment();
    const batchResult = await batchProcessor.ProcessBatch(commentEntities, {
      onProgress: (done, total, failed) => {
        processedCount = done;
        failedCount = loadFailedCount + failed;
        const processProgress = 35 + Math.floor((done / safeTotalToProcess) * 20);
        const currentState =
          done < totalToProcess * 0.5 ? "sending_openai" : "generating_tags";
        progressMap.set(report.rid, {
          trace_id: traceId,
          percent: processProgress,
          message:
            done < totalToProcess * 0.5
              ? `Sending to OpenAI... (${done}/${totalToProcess})`
              : `Generating tags... (${done}/${totalToProcess})`,
          state: currentState,
          startTime,
        });
      },
    });
    processedCount = batchResult.processedCount;
    failedCount = loadFailedCount + batchResult.failedCount;
    logUpload("info", "stage_comment_processing_finished", {
      trace_id: traceId,
      rid: report.rid,
      processed: processedCount,
      failed: failedCount,
    });

    progressMap.set(report.rid, {
      trace_id: traceId,
      percent: 55,
      message: "Placing tags in database...",
      state: "placing_tags",
      startTime,
    });

    console.log(
      `üîç [DEBUG] Category processing complete: ${processedCount} successful, ${failedCount} failed`
    );

    const themeCounts = await summarizeReportThemes(report.rid);
    const sanitizedThemeFileName = sanitizeFilePath(
      `themes_summary_${report.rid}.json`
    );
    if (!sanitizedThemeFileName) {
      throw new Error("Invalid file name");
    }

    const themeSummaryPath = path.resolve(
      global.__basedir,
      "tmp",
      sanitizedThemeFileName
    );
    if (!themeSummaryPath.startsWith(path.resolve(global.__basedir, "tmp"))) {
      throw new Error("Invalid file path");
    }
    await fs.writeFile(themeSummaryPath, JSON.stringify(themeCounts, null, 2), "utf-8");
    logUpload("info", "stage_theme_summary_written", {
      trace_id: traceId,
      rid: report.rid,
      theme_count: Object.keys(themeCounts || {}).length,
      theme_summary_path: themeSummaryPath,
    });

    progressMap.set(report.rid, {
      trace_id: traceId,
      percent: 60,
      message: "Generating summary from themes...",
      state: "generating_summary",
      startTime,
    });

    const jsonPath = await prepareSummaryData(report.rid);
    logUpload("info", "stage_summary_input_prepared", {
      trace_id: traceId,
      rid: report.rid,
      json_path: jsonPath,
    });
    const { summary } = await runPythonCodebookPipeline(jsonPath, report.rid);
    logUpload("info", "stage_python_pipeline_completed", {
      trace_id: traceId,
      rid: report.rid,
      summary_length: summary ? summary.length : 0,
    });

    const recodedPath = path.resolve(global.__basedir, "recoded_comments.json");
    let recoded = [];
    if (fsSync.existsSync(recodedPath)) {
      const content = fsSync.readFileSync(recodedPath, "utf-8");
      recoded = JSON.parse(content);

      for (const entry of recoded) {
        if (!entry.cid || !Array.isArray(entry.categories)) continue;
        const comment = new Comment();
        try {
          await comment.Get(entry.cid);
          await comment.SaveSetting("categories", JSON.stringify(entry.categories));
        } catch (err) {
          console.warn(
            `‚ö†Ô∏è Failed to save categories for comment ${entry.cid}:`,
            err.message
          );
        }
      }
    }
    logUpload("info", "stage_recoded_loaded", {
      trace_id: traceId,
      rid: report.rid,
      recoded_count: recoded.length,
    });

    progressMap.set(report.rid, {
      trace_id: traceId,
      percent: 90,
      message: "Finalizing report...",
      state: "finalizing",
      startTime,
    });

    const settingsToSave = {};
    if (summary) {
      console.log(
        `üîç [DEBUG] Saving summary for report ${report.rid}:`,
        summary.substring(0, 200) + "..."
      );
      settingsToSave.summary_text = summary;
    } else {
      console.log(`‚ö†Ô∏è [WARNING] No summary generated for report ${report.rid}`);
    }
    if (recoded_output_json) {
      settingsToSave.recoded_output_json = recoded_output_json;
    } else if (recoded.length > 0) {
      settingsToSave.recoded_output_json = JSON.stringify(recoded);
    }
    if (codebook_json) settingsToSave.codebook_json = codebook_json;

    await report.SaveSettings(settingsToSave);
    await report.SaveSetting("themes_summary_json", JSON.stringify(themeCounts));
    logUpload("info", "stage_settings_saved", {
      trace_id: traceId,
      rid: report.rid,
      settings_keys: Object.keys(settingsToSave),
    });

    const totalTime = Date.now() - startTime;
    progressMap.set(report.rid, {
      trace_id: traceId,
      percent: 100,
      message: "Complete!",
      state: "complete",
      startTime,
      totalTime,
    });
    logUpload("info", "pipeline_completed", {
      trace_id: traceId,
      uid,
      rid: report.rid,
      duration_ms: Date.now() - startTime,
    });
  } catch (err) {
    logUpload("error", "pipeline_failed", {
      trace_id: traceId,
      uid,
      rid: report.rid,
      duration_ms: Date.now() - startTime,
      error: err?.message || "Unknown error",
      stack: err?.stack || null,
    });
    progressMap.set(report.rid, {
      trace_id: traceId,
      percent: 0,
      message: `Error: ${err.message || "Upload failed"}`,
      state: "error",
      error: err.message || "Unknown error",
      startTime,
    });
  }
}

ReportRouter.post("/upload", requireAuth, async (req, res) => {
  try {
    const traceId = crypto.randomUUID();
    const clientTraceId = req.get("X-Client-Trace-Id") || null;
    const {
      professor,
      course_code,
      semester,
      csv_text,
      codebook_json,
      summary_text,
      recoded_output_json,
    } = req.body;

    // Keep for backwards compatibility with existing clients that may send it.
    void summary_text;

    if (!professor || !course_code || !semester || !csv_text) {
      return res.status(400).json({
        error: "Missing required fields: professor, course_code, semester, or csv_text",
      });
    }

    const validatedProfessor = validateText(professor, 255);
    const validatedCourseCode = validateText(course_code, 50);
    const validatedSemester = validateText(semester, 50);
    if (!validatedProfessor || !validatedCourseCode || !validatedSemester) {
      return res.status(400).json({
        error: "Invalid input format. Please check your input fields.",
      });
    }

    const csvValidation = validateCSV(csv_text, 10);
    if (!csvValidation.valid) {
      return res.status(400).json({ error: csvValidation.error });
    }

    let records;
    try {
      records = parse(csv_text, {
        delimiter: "\t",
        skip_empty_lines: true,
        relax_quotes: true,
        quote: '"',
        escape: '"',
        relax_column_count: true,
      });
    } catch (parseError) {
      console.error("‚ùå CSV parsing failed:", parseError);
      return res.status(400).json({
        error: "Failed to parse CSV file. Please ensure it's a valid tab-separated CSV.",
      });
    }

    if (!Array.isArray(records) || records.length === 0) {
      return res.status(400).json({
        error: "CSV file appears to be empty or invalid",
      });
    }

    const comments = records
      .slice(1)
      .map((row) => String(row?.[3] ?? "").trim())
      .filter((text) => text && !text.startsWith("Question:"));

    const uid = req.session.user.uid;
    logUpload("info", "request_received", {
      trace_id: traceId,
      client_trace_id: clientTraceId,
      uid,
      professor: validatedProfessor,
      course_code: validatedCourseCode,
      semester: validatedSemester,
      csv_bytes: Buffer.byteLength(csv_text, "utf8"),
      rows: records.length,
      comments_count: comments.length,
    });

    res.set("X-Upload-Trace-Id", traceId);
    const csv_hash = crypto.createHash("sha256").update(csv_text).digest("hex");

    const nameParts = validatedProfessor.split(" ");
    const first = validateText(nameParts[0], 100) || "Unknown";
    const last =
      nameParts.length > 1
        ? validateText(nameParts.slice(1).join(" "), 100) || "(none)"
        : "(none)";

    let [result] = await db.query(
      "SELECT pid FROM professors WHERE first_name = $1 AND last_name = $2",
      [first, last]
    );

    let pid = result?.pid;
    if (!pid) {
      const insert = await db.query(
        "INSERT INTO professors (first_name, last_name) VALUES ($1, $2) RETURNING pid",
        [first, last]
      );
      pid = insert[0].pid;
    }

    const existing = await db.query(
      `SELECT rid FROM reports WHERE pid = $1 AND course_code = $2 AND semester = $3 AND csv_hash = $4 AND uid = $5 LIMIT 1`,
      [pid, validatedCourseCode, validatedSemester, csv_hash, uid]
    );

    let report;
    if (existing.length > 0) {
      report = new Report();
      await report.Get(existing[0].rid);
      const summary = await report.GetSetting("summary_text");
      const recoded = await report.GetSetting("recoded_output_json");
      const codebook = await report.GetSetting("codebook_json");
      logUpload("info", "cache_hit", {
        trace_id: traceId,
        uid,
        rid: report.rid,
      });
      return res.json({
        report,
        summary,
        recoded,
        codebook,
        cached: true,
        trace_id: traceId,
      });
    }

    report = new Report();
    report.name = `${validatedProfessor} ‚Äì ${validatedCourseCode} (${validatedSemester})`;
    await report.Create(uid);

    const queuedAt = Date.now();
    progressMap.set(report.rid, {
      trace_id: traceId,
      percent: 1,
      message: "Queued for processing...",
      state: "queued",
      startTime: queuedAt,
    });
    logUpload("info", "queued", {
      trace_id: traceId,
      uid,
      rid: report.rid,
      queued_at: queuedAt,
    });

    processUploadInBackground({
      traceId,
      uid,
      report,
      comments,
      pid,
      validatedCourseCode,
      validatedSemester,
      csv_hash,
      csv_text,
      codebook_json,
      recoded_output_json,
    }).catch((err) => {
      logUpload("error", "background_unhandled_error", {
        trace_id: traceId,
        uid,
        rid: report.rid,
        error: err?.message || "Unknown error",
        stack: err?.stack || null,
      });
      progressMap.set(report.rid, {
        trace_id: traceId,
        percent: 0,
        message: `Error: ${err.message || "Upload failed"}`,
        state: "error",
        error: err.message || "Unknown error",
        startTime: queuedAt,
      });
    });

    return res.status(202).json({
      report,
      cached: false,
      queued: true,
      trace_id: traceId,
    });
  } catch (err) {
    logUpload("error", "request_failed_before_queue", {
      error: err?.message || "Unknown error",
      stack: err?.stack || null,
    });
    const errorResponse = safeErrorResponse(
      err,
      process.env.NODE_ENV === "development"
    );
    res.status(500).json(errorResponse);
  }
});

ReportRouter.post("/:rid/delete", requireAuth, async (req, res) => {
  try {
    const rid = validateId(req.params.rid);
    if (!rid) {
      return res.status(400).json({ error: "Invalid report ID" });
    }
    
    // Verify ownership before deletion
    const reportCheck = await db.query(
      `SELECT uid FROM reports WHERE rid = $1 LIMIT 1`,
      [rid]
    );
    if (reportCheck.length === 0) {
      return res.status(404).json({ error: "Report not found" });
    }
    if (reportCheck[0].uid !== req.session.user.uid) {
      return res.status(403).json({ error: "Access denied" });
    }
    
    await db.query(`DELETE FROM comments WHERE rid = $1`, [rid]);
    await db.query(`DELETE FROM reports_settings WHERE rid = $1`, [rid]);
    await db.query(`DELETE FROM reports WHERE rid = $1`, [rid]);
    res.json({ success: true });
  } catch (err) {
    console.error("Failed to delete report:", err);
    const errorResponse = safeErrorResponse(err, process.env.NODE_ENV === "development");
    res.status(500).json(errorResponse);
  }
});

ReportRouter.get("/:rid", (req, res) => {
  res.sendFile(path.resolve(global.__basedir, "public/pages/report.html"));
});

export async function summarizeReportThemes(rid) {
  console.log(`üîç [DEBUG] Summarizing categories for report ${rid}`);
  // Get categories from comments_settings table, not main table
  const rows = await db.query(
    `SELECT c.cid, cs.value as categories 
     FROM comments c
     LEFT JOIN comments_settings cs ON c.cid = cs.cid AND cs.name = 'categories'
     WHERE c.rid = $1`,
    [rid]
  );
  console.log(
    `üîç [DEBUG] Found ${rows.length} comments for category summarization`
  );

  const themeCounts = {};
  let commentsWithCategories = 0;

  for (const row of rows) {
    if (!row.categories) {
      // console.log(`üîç [DEBUG] Comment has no categories for summarization`);
      continue;
    }

    commentsWithCategories++;
    const categories = parseCategoryList(row.categories);

    // console.log(`üîç [DEBUG] Processing categories for summarization: [${categories.join(', ')}]`);

    for (const category of categories) {
      themeCounts[category] = (themeCounts[category] || 0) + 1;
    }
  }

  console.log(
    `üîç [DEBUG] Category summarization complete: ${commentsWithCategories}/${rows.length} comments had categories`
  );
  console.log(`üîç [DEBUG] Final category counts:`, themeCounts);

  return themeCounts;
}

function runPythonCodebookPipeline(jsonPath, reportId) {
  return new Promise((resolve, reject) => {
    console.log(
      `üîç [DEBUG] Starting Python pipeline for report ${reportId} with data from ${jsonPath}`
    );

    // ‚úÖ Default to system python3 (for Render)
    let pythonPath = "python3";

    // ‚úÖ Use local venv python if it exists
    const localVenvPath = path.resolve(
      __dirname,
      "..",
      "venv",
      process.platform === "win32" ? "Scripts/python.exe" : "bin/python3"
    );

    if (fsSync.existsSync(localVenvPath)) {
      pythonPath = localVenvPath;
      console.log(`üîç [DEBUG] Using local venv python: ${pythonPath}`);
    } else {
      console.log(`üîç [DEBUG] Using system python: ${pythonPath}`);
    }

    const proc = spawn(pythonPath, [
      "codebook_pipeline.py",
      jsonPath,
      String(reportId),
    ]);

    let output = "";
    let errorOutput = "";

    proc.stdout.on("data", (chunk) => {
      const data = chunk.toString();
      output += data;
      // console.log(`üîç [DEBUG] Python stdout: ${data}`);
    });

    proc.stderr.on("data", (err) => {
      const error = err.toString();
      errorOutput += error;
      console.error("üîç [DEBUG] Python stderr:", error);
    });

    proc.on("error", (err) => {
      reject(new Error(`Failed to start Python pipeline: ${err.message}`));
    });

    proc.on("close", (code) => {
      console.log(`üîç [DEBUG] Python process exited with code ${code}`);
      if (code !== 0) {
        console.error(`‚ùå [ERROR] Python pipeline failed with code ${code}`);
        console.error(`‚ùå [ERROR] Error output: ${errorOutput}`);
        return reject(
          new Error(`Python exited with code ${code}: ${errorOutput}`)
        );
      }
      try {
        const result = JSON.parse(output);
        // console.log(`üîç [DEBUG] Python pipeline result:`, result);
        resolve(result);
      } catch (err) {
        console.error(
          `‚ùå [ERROR] Failed to parse Python output: ${err.message}`
        );
        console.error(`‚ùå [ERROR] Raw output: ${output}`);
        reject(new Error("Invalid JSON from Python: " + err.message));
      }
    });
  });
}

async function prepareSummaryData(rid) {
  console.log(`üîç [DEBUG] Preparing summary data for report ${rid}`);

  // Get categories from comments_settings table, not main table
  const rows = await db.query(
    `SELECT c.text, cs.value as categories 
     FROM comments c
     LEFT JOIN comments_settings cs ON c.cid = cs.cid AND cs.name = 'categories'
     WHERE c.rid = $1`,
    [rid]
  );

  console.log(`üîç [DEBUG] Found ${rows.length} comments for report ${rid}`);

  const themeCounts = {};
  const commentsByTheme = {};
  let commentsWithCategories = 0;
  let totalCategories = 0;

  for (const row of rows) {
    if (!row.categories) {
      const textPreview = String(row.text ?? "").substring(0, 50);
      console.log(`üîç [DEBUG] Comment has no categories: "${textPreview}..."`);
      continue;
    }

    commentsWithCategories++;
    const categories = parseCategoryList(row.categories);

    // console.log(`üîç [DEBUG] Comment categories: [${categories.join(', ')}] for text: "${row.text.substring(0, 50)}..."`);

    for (const category of categories) {
      themeCounts[category] = (themeCounts[category] || 0) + 1;
      totalCategories++;
      if (!commentsByTheme[category]) {
        commentsByTheme[category] = [];
      }
      commentsByTheme[category].push(String(row.text ?? ""));
    }
  }

  console.log(
    `üîç [DEBUG] Summary stats: ${commentsWithCategories}/${rows.length} comments have categories, ${totalCategories} total category occurrences`
  );
  console.log(`üîç [DEBUG] Category counts:`, themeCounts);
  console.log(`üîç [DEBUG] Comments by category:`, Object.keys(commentsByTheme));

  const data = {
    themes: themeCounts,
    comments_by_theme: commentsByTheme,
  };

    const sanitizedSummaryFileName = sanitizeFilePath(`summary_input_${rid}.json`);
    if (!sanitizedSummaryFileName) {
      throw new Error("Invalid file name");
    }
    
    const tempPath = path.resolve(
      global.__basedir,
      "tmp",
      sanitizedSummaryFileName
    );
    
    // Ensure we're writing to the tmp directory
    if (!tempPath.startsWith(path.resolve(global.__basedir, "tmp"))) {
      throw new Error("Invalid file path");
    }
    
    await fs.writeFile(tempPath, JSON.stringify(data, null, 2), "utf-8");
    console.log(`üîç [DEBUG] Summary data written to: ${tempPath}`);
    return tempPath;
}
