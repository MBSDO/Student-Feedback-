console.log("üîß report.mjs is executing...");

import express from "express";
import { db } from "./db.mjs";
import path from "path";
import fs from "fs/promises";
import fsSync from "fs";
import crypto from "crypto";
import { spawn } from "child_process";
import { fileURLToPath } from "url";
import { parse } from "csv-parse/sync";
import { Comment } from "./comment.mjs";
import {
  requireAuth,
  validateId,
  validateText,
  validateCSV,
  sanitizeString,
  safeErrorResponse,
  sanitizeFilePath,
} from "./security.mjs";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ‚úÖ Global in-memory progress tracker with timestamps for ETA calculation
const progressMap = new Map();

export class Report {
  constructor() {
    this.tableName = "reports";
    this.primaryKey = "rid";
    this.rid = null;
    this.uid = null;
    this.name = "";
    this.updated = null;
    this.exists = false;
  }

  async Create(uid) {
    const result = await db.query(
      `INSERT INTO ${this.tableName} (uid, name, updated)
       VALUES ($1, $2, NOW())
       RETURNING rid`,
      [uid, this.name || "Untitled Report"]
    );
    await this.Get(result[0].rid);
  }

  async Get(rid) {
    const rows = await db.query(
      `SELECT * FROM ${this.tableName} WHERE ${this.primaryKey} = $1 LIMIT 1`,
      [rid]
    );
    if (rows.length === 0) return false;
    Object.assign(this, rows[0]);
    this.exists = true;
    return true;
  }

  async SaveSettings(settings) {
    for (const key in settings) {
      await db.query(
        `INSERT INTO reports_settings (rid, name, value)
         VALUES ($1, $2, $3)
         ON CONFLICT (rid, name) DO UPDATE SET value = EXCLUDED.value`,
        [this.rid, key, settings[key]]
      );
    }
  }

  async SaveSetting(name, value) {
    await this.SaveSettings({ [name]: value });
  }

  async GetSetting(key) {
    const rows = await db.query(
      `SELECT value FROM reports_settings WHERE rid = $1 AND name = $2 LIMIT 1`,
      [this.rid, key]
    );
    return rows[0]?.value || null;
  }
}

export const ReportRouter = express.Router();

ReportRouter.get("/test-health", (req, res) => {
  res.json({ status: "alive" });
});

ReportRouter.get("/list", (req, res, next) => {
  if (req.accepts("html")) {
    return res.sendFile(
      path.resolve(global.__basedir, "public/pages/reports.html")
    );
  }
  return next();
});

ReportRouter.get("/list/data", requireAuth, async (req, res) => {
  try {
    const uid = req.session.user.uid; // Already validated by requireAuth
    const rows = await db.query(
      `SELECT rid, name, updated FROM reports WHERE uid = $1 ORDER BY updated DESC`,
      [uid]
    );
    const commentCounts = await db.query(
      `SELECT rid, COUNT(*) AS comments_count FROM comments GROUP BY rid`
    );
    const countMap = Object.fromEntries(
      commentCounts.map((row) => [row.rid, parseInt(row.comments_count)])
    );
    const result = rows.map((row) => ({
      ...row,
      comments_count: countMap[row.rid] || 0,
    }));
    res.json(result);
  } catch (err) {
    console.error("‚ùå Failed to fetch report list:", err);
    res.status(500).json({ error: "Internal server error" });
  }
});

ReportRouter.get("/create", requireAuth, async (req, res) => {
  try {
    const uid = req.session.user.uid; // Already validated by requireAuth
    const professor = validateText(req.query.professor, 255) || "Unknown Professor";
    const course = validateText(req.query.course, 255) || "Untitled Course";
    const report = new Report();
    report.name = `${professor} ‚Äì ${course}`;
    await report.Create(uid);
    res.json({
      rid: report.rid,
      name: report.name,
      updated: report.updated,
      comments_count: 0,
    });
  } catch (err) {
    res.status(500).json({ error: "Failed to create report" });
  }
});

// ‚úÖ New: Progress polling endpoint with ETA calculation
ReportRouter.get("/progress/:rid", requireAuth, (req, res) => {
  const rid = validateId(req.params.rid);
  if (!rid) {
    return res.status(400).json({ error: "Invalid report ID" });
  }
  
  // Verify user owns this report
  // Note: This is a simple check - in production, verify ownership from DB
  const progress = progressMap.get(rid);
  if (progress) {
    const response = { ...progress };
    
    // Calculate ETA if we have enough data
    if (progress.startTime && progress.percent > 5 && progress.percent < 100) {
      const elapsed = Date.now() - progress.startTime;
      const rate = progress.percent / elapsed; // percent per millisecond
      const remaining = 100 - progress.percent;
      const estimatedRemaining = remaining / rate; // milliseconds
      response.eta = Math.max(0, Math.round(estimatedRemaining / 1000)); // seconds
    } else {
      response.eta = null;
    }
    
    res.json(response);
  } else {
    res.json({ percent: 0, message: "Initializing...", state: "initializing", eta: null });
  }
});

ReportRouter.all("/:rid/view", requireAuth, async (req, res) => {
  try {
    const rid = validateId(req.params.rid);
    if (!rid) {
      return res.status(400).json({ error: "Invalid report ID" });
    }
    
    const report = new Report();
    const found = await report.Get(rid);
    if (!found) return res.status(404).json({ error: "Report not found" });
    
    // Verify ownership
    if (report.uid !== req.session.user.uid) {
      return res.status(403).json({ error: "Access denied" });
    }

    // Fetch the summary text from settings
    const summary_text = await report.GetSetting("summary_text");
    const theme_summary_json = await report.GetSetting("themes_summary_json");

    // Add summary_text to the response
    const reportData = {
      ...report,
      summary_text,
      theme_summary: JSON.parse(theme_summary_json || "{}"),
    };

    res.json(reportData);
  } catch (err) {
    res.status(500).json({ error: "Internal server error" });
  }
});

ReportRouter.get("/:rid/comments", requireAuth, async (req, res) => {
  try {
    const rid = validateId(req.params.rid);
    if (!rid) {
      return res.status(400).json({ error: "Invalid report ID" });
    }
    
    // Verify ownership
    const reportCheck = await db.query(
      `SELECT uid FROM reports WHERE rid = $1 LIMIT 1`,
      [rid]
    );
    if (reportCheck.length === 0) {
      return res.status(404).json({ error: "Report not found" });
    }
    if (reportCheck[0].uid !== req.session.user.uid) {
      return res.status(403).json({ error: "Access denied" });
    }
    
    const rows = await db.query(
      `SELECT * FROM comments WHERE rid = $1 ORDER BY cid ASC`,
      [rid]
    );
    res.json(rows);
  } catch (err) {
    console.error("Error fetching comments:", err);
    res.status(500).json({ error: "Internal server error" });
  }
});

ReportRouter.post("/upload", requireAuth, async (req, res) => {
  try {
    const {
      professor,
      course_code,
      semester,
      csv_text,
      codebook_json,
      summary_text,
      recoded_output_json,
    } = req.body;

    // Validate required fields
    if (!professor || !course_code || !semester || !csv_text) {
      return res.status(400).json({
        error: "Missing required fields: professor, course_code, semester, or csv_text",
      });
    }

    // Validate and sanitize inputs
    const validatedProfessor = validateText(professor, 255);
    const validatedCourseCode = validateText(course_code, 50);
    const validatedSemester = validateText(semester, 50);
    
    if (!validatedProfessor || !validatedCourseCode || !validatedSemester) {
      return res.status(400).json({
        error: "Invalid input format. Please check your input fields.",
      });
    }

    // Validate CSV
    const csvValidation = validateCSV(csv_text, 10); // Max 10MB
    if (!csvValidation.valid) {
      return res.status(400).json({ error: csvValidation.error });
    }

    let records;
    try {
      records = parse(csv_text, {
        delimiter: "\t",
        skip_empty_lines: true,
        relax_quotes: true,
        quote: '"',
        escape: '"',
        relax_column_count: true,
      });
    } catch (parseError) {
      console.error("‚ùå CSV parsing failed:", parseError);
      return res.status(400).json({
        error: "Failed to parse CSV file. Please ensure it's a valid tab-separated CSV.",
      });
    }

    if (!Array.isArray(records) || records.length === 0) {
      return res.status(400).json({ error: "CSV file appears to be empty or invalid" });
    }

    const comments = records
      .slice(1)
      .map((row) => row[3]?.trim())
      .filter((text) => text && !text.startsWith("Question:"));

    const uid = req.session.user.uid;
    const csv_hash = crypto.createHash("sha256").update(csv_text).digest("hex");

    const nameParts = validatedProfessor.split(" ");
    const first = validateText(nameParts[0], 100) || "Unknown";
    const last = nameParts.length > 1 
      ? validateText(nameParts.slice(1).join(" "), 100) || "(none)"
      : "(none)";

    let [result] = await db.query(
      "SELECT pid FROM professors WHERE first_name = $1 AND last_name = $2",
      [first, last]
    );

    let pid = result?.pid;
    if (!pid) {
      const insert = await db.query(
        "INSERT INTO professors (first_name, last_name) VALUES ($1, $2) RETURNING pid",
        [first, last]
      );
      pid = insert[0].pid;
    }

    const existing = await db.query(
      `SELECT rid FROM reports WHERE pid = $1 AND course_code = $2 AND semester = $3 AND csv_hash = $4 AND uid = $5 LIMIT 1`,
      [pid, validatedCourseCode, validatedSemester, csv_hash, uid]
    );

    let report;
    if (existing.length > 0) {
      report = new Report();
      await report.Get(existing[0].rid);
      const summary = await report.GetSetting("summary_text");
      const recoded = await report.GetSetting("recoded_output_json");
      const codebook = await report.GetSetting("codebook_json");
      return res.json({ report, summary, recoded, codebook, cached: true });
    }

    report = new Report();
    report.name = `${validatedProfessor} ‚Äì ${validatedCourseCode} (${validatedSemester})`;
    await report.Create(uid);

    const startTime = Date.now();
    
    // ‚úÖ Progress update: reading file
    progressMap.set(report.rid, { 
      percent: 5, 
      message: "Reading file...",
      state: "reading_file",
      startTime 
    });

    // ‚úÖ Progress update: saving comments
    const totalComments = comments.length;
    progressMap.set(report.rid, { 
      percent: 10, 
      message: `Saving ${totalComments} comments to database...`,
      state: "saving_comments",
      startTime 
    });

    let savedCount = 0;
    for (const text of comments) {
      const comment = new Comment();
      try {
        await comment.Create(report.rid, text);
        savedCount++;
        // Update progress every 10 comments or at the end
        if (savedCount % 10 === 0 || savedCount === totalComments) {
          const commentProgress = 10 + Math.floor((savedCount / totalComments) * 15);
          progressMap.set(report.rid, { 
            percent: commentProgress, 
            message: `Saving comments... (${savedCount}/${totalComments})`,
            state: "saving_comments",
            startTime 
          });
        }
      } catch (err) {
        console.warn("‚ö†Ô∏è Failed to insert comment:", err.message);
      }
    }

    // ‚úÖ Progress update: writing metadata
    progressMap.set(report.rid, {
      percent: 25,
      message: "Writing metadata...",
      state: "writing_metadata",
      startTime
    });

    await db.query(
      `UPDATE reports SET pid = $1, course_code = $2, semester = $3, csv_hash = $4 WHERE rid = $5`,
      [pid, validatedCourseCode, validatedSemester, csv_hash, report.rid]
    );

    // ‚úÖ Progress update: comparing with codebook
    progressMap.set(report.rid, {
      percent: 30,
      message: "Comparing comments with codebook...",
      state: "comparing_codebook",
      startTime
    });

    if (!fsSync.existsSync(path.resolve(global.__basedir, "tmp"))) {
      fsSync.mkdirSync(path.resolve(global.__basedir, "tmp"));
    }

    // Sanitize file path to prevent directory traversal
    const sanitizedFileName = sanitizeFilePath(`report_${report.rid}.csv`);
    if (!sanitizedFileName) {
      throw new Error("Invalid file name");
    }
    
    const tempPath = path.resolve(
      global.__basedir,
      "tmp",
      sanitizedFileName
    );
    
    // Ensure we're writing to the tmp directory (prevent directory traversal)
    if (!tempPath.startsWith(path.resolve(global.__basedir, "tmp"))) {
      throw new Error("Invalid file path");
    }
    
    await fs.writeFile(tempPath, csv_text);

    // ‚úÖ NEW: Process themes for all comments before summary generation
    console.log(
      `üîç [DEBUG] Processing categories for all comments in report ${report.rid}`
    );
    const commentRows = await db.query(
      "SELECT cid, text FROM comments WHERE rid = $1",
      [report.rid]
    );

    const totalToProcess = commentRows.length;
    let processedCount = 0;
    let failedCount = 0;

    // Update progress: sending to OpenAI
    progressMap.set(report.rid, {
      percent: 35,
      message: `Sending comments to OpenAI for analysis... (0/${totalToProcess})`,
      state: "sending_openai",
      startTime
    });

    for (const row of commentRows) {
      try {
        const comment = new Comment();
        await comment.Get(row.cid);
        await comment.Process(); // This will extract and save categories
        processedCount++;
        
        // Update progress every 5 comments or at milestones
        if (processedCount % 5 === 0 || processedCount === totalToProcess) {
          const processProgress = 35 + Math.floor((processedCount / totalToProcess) * 20);
          const currentState = processedCount < totalToProcess * 0.5 
            ? "sending_openai" 
            : "generating_tags";
          progressMap.set(report.rid, {
            percent: processProgress,
            message: processedCount < totalToProcess * 0.5
              ? `Sending to OpenAI... (${processedCount}/${totalToProcess})`
              : `Generating tags... (${processedCount}/${totalToProcess})`,
            state: currentState,
            startTime
          });
        }
      } catch (err) {
        console.warn(
          `‚ö†Ô∏è Failed to process categories for comment ${row.cid}:`,
          err.message
        );
        failedCount++;
      }
    }

    // Update progress: placing tags
    progressMap.set(report.rid, {
      percent: 55,
      message: "Placing tags in database...",
      state: "placing_tags",
      startTime
    });

    console.log(
      `üîç [DEBUG] Category processing complete: ${processedCount} successful, ${failedCount} failed`
    );

    const themeCounts = await summarizeReportThemes(report.rid);
    const sanitizedThemeFileName = sanitizeFilePath(`themes_summary_${report.rid}.json`);
    if (!sanitizedThemeFileName) {
      throw new Error("Invalid file name");
    }
    
    const themeSummaryPath = path.resolve(
      global.__basedir,
      "tmp",
      sanitizedThemeFileName
    );
    
    // Ensure we're writing to the tmp directory
    if (!themeSummaryPath.startsWith(path.resolve(global.__basedir, "tmp"))) {
      throw new Error("Invalid file path");
    }
    
    await fs.writeFile(
      themeSummaryPath,
      JSON.stringify(themeCounts, null, 2),
      "utf-8"
    );

    // ‚úÖ Progress update: generating summary
    progressMap.set(report.rid, {
      percent: 60,
      message: "Generating summary from themes...",
      state: "generating_summary",
      startTime
    });

    const jsonPath = await prepareSummaryData(report.rid);
    const { summary, top_5_themes, related_comments } =
      await runPythonCodebookPipeline(jsonPath, report.rid);

    const recodedPath = path.resolve(global.__basedir, "recoded_comments.json");
    let recoded = [];

    if (fsSync.existsSync(recodedPath)) {
      const content = fsSync.readFileSync(recodedPath, "utf-8");
      recoded = JSON.parse(content);

      for (const entry of recoded) {
        if (!entry.cid || !Array.isArray(entry.categories)) continue;

        // Use SaveSettings to save to comments_settings table
        // This works even if categories column doesn't exist in main table
        const comment = new Comment();
        try {
          await comment.Get(entry.cid);
          await comment.SaveSetting("categories", JSON.stringify(entry.categories));
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to save categories for comment ${entry.cid}:`, err.message);
        }
      }
    }

    // ‚úÖ Progress update: finalizing
    progressMap.set(report.rid, { 
      percent: 90, 
      message: "Finalizing report...",
      state: "finalizing",
      startTime
    });

    const settingsToSave = {};
    if (summary) {
      console.log(
        `üîç [DEBUG] Saving summary for report ${report.rid}:`,
        summary.substring(0, 200) + "..."
      );
      settingsToSave.summary_text = summary;
    } else {
      console.log(`‚ö†Ô∏è [WARNING] No summary generated for report ${report.rid}`);
    }
    if (recoded_output_json)
      settingsToSave.recoded_output_json = recoded_output_json;
    if (codebook_json) settingsToSave.codebook_json = codebook_json;

    await report.SaveSettings(settingsToSave);
    await report.SaveSetting(
      "themes_summary_json",
      JSON.stringify(themeCounts)
    );

    // ‚úÖ Done
    const totalTime = Date.now() - startTime;
    progressMap.set(report.rid, { 
      percent: 100, 
      message: "Complete!",
      state: "complete",
      startTime,
      totalTime
    });

    // Safely parse codebook_json
    let codebook = {};
    if (codebook_json) {
      try {
        codebook = JSON.parse(codebook_json);
      } catch (parseErr) {
        console.warn("‚ö†Ô∏è Failed to parse codebook_json:", parseErr.message);
        codebook = {};
      }
    }

    res.json({
      report,
      summary,
      recoded,
      codebook,
      theme_summary: themeCounts,
      cached: false,
    });
  } catch (err) {
    console.error("‚ùå Upload failed:", err);
    console.error("‚ùå Error stack:", err.stack);
    const errorResponse = safeErrorResponse(err, process.env.NODE_ENV === "development");
    res.status(500).json(errorResponse);
  }
});

ReportRouter.post("/:rid/delete", requireAuth, async (req, res) => {
  try {
    const rid = validateId(req.params.rid);
    if (!rid) {
      return res.status(400).json({ error: "Invalid report ID" });
    }
    
    // Verify ownership before deletion
    const reportCheck = await db.query(
      `SELECT uid FROM reports WHERE rid = $1 LIMIT 1`,
      [rid]
    );
    if (reportCheck.length === 0) {
      return res.status(404).json({ error: "Report not found" });
    }
    if (reportCheck[0].uid !== req.session.user.uid) {
      return res.status(403).json({ error: "Access denied" });
    }
    
    await db.query(`DELETE FROM comments WHERE rid = $1`, [rid]);
    await db.query(`DELETE FROM reports_settings WHERE rid = $1`, [rid]);
    await db.query(`DELETE FROM reports WHERE rid = $1`, [rid]);
    res.json({ success: true });
  } catch (err) {
    console.error("Failed to delete report:", err);
    const errorResponse = safeErrorResponse(err, process.env.NODE_ENV === "development");
    res.status(500).json(errorResponse);
  }
});

ReportRouter.get("/:rid", (req, res) => {
  res.sendFile(path.resolve(global.__basedir, "public/pages/report.html"));
});

export async function summarizeReportThemes(rid) {
  console.log(`üîç [DEBUG] Summarizing categories for report ${rid}`);
  // Get categories from comments_settings table, not main table
  const rows = await db.query(
    `SELECT c.cid, cs.value as categories 
     FROM comments c
     LEFT JOIN comments_settings cs ON c.cid = cs.cid AND cs.name = 'categories'
     WHERE c.rid = $1`,
    [rid]
  );
  console.log(
    `üîç [DEBUG] Found ${rows.length} comments for category summarization`
  );

  const themeCounts = {};
  let commentsWithCategories = 0;

  for (const row of rows) {
    if (!row.categories) {
      // console.log(`üîç [DEBUG] Comment has no categories for summarization`);
      continue;
    }

    commentsWithCategories++;
    let categories = [];

    try {
      // Try to parse as JSON first
      if (typeof row.categories === "string") {
        categories = JSON.parse(row.categories);
      } else if (Array.isArray(row.categories)) {
        categories = row.categories;
      } else {
        // Fallback: try comma-separated string
        categories = row.categories
          .split(",")
          .map((t) => t.trim())
          .filter(Boolean);
      }
    } catch (err) {
      console.warn(`‚ö†Ô∏è Failed to parse categories for comment: ${err.message}`);
      // Fallback: try comma-separated string
      categories = row.categories
        .split(",")
        .map((t) => t.trim())
        .filter(Boolean);
    }

    // console.log(`üîç [DEBUG] Processing categories for summarization: [${categories.join(', ')}]`);

    for (const category of categories) {
      themeCounts[category] = (themeCounts[category] || 0) + 1;
    }
  }

  console.log(
    `üîç [DEBUG] Category summarization complete: ${commentsWithCategories}/${rows.length} comments had categories`
  );
  console.log(`üîç [DEBUG] Final category counts:`, themeCounts);

  return themeCounts;
}

function runPythonCodebookPipeline(jsonPath, reportId) {
  return new Promise((resolve, reject) => {
    console.log(
      `üîç [DEBUG] Starting Python pipeline for report ${reportId} with data from ${jsonPath}`
    );

    // ‚úÖ Default to system python3 (for Render)
    let pythonPath = "python3";

    // ‚úÖ Use local venv python if it exists
    const localVenvPath = path.resolve(
      __dirname,
      "..",
      "venv",
      process.platform === "win32" ? "Scripts/python.exe" : "bin/python3"
    );

    if (fsSync.existsSync(localVenvPath)) {
      pythonPath = localVenvPath;
      console.log(`üîç [DEBUG] Using local venv python: ${pythonPath}`);
    } else {
      console.log(`üîç [DEBUG] Using system python: ${pythonPath}`);
    }

    const proc = spawn(pythonPath, [
      "codebook_pipeline.py",
      jsonPath,
      String(reportId),
    ]);

    let output = "";
    let errorOutput = "";

    proc.stdout.on("data", (chunk) => {
      const data = chunk.toString();
      output += data;
      // console.log(`üîç [DEBUG] Python stdout: ${data}`);
    });

    proc.stderr.on("data", (err) => {
      const error = err.toString();
      errorOutput += error;
      console.error("üîç [DEBUG] Python stderr:", error);
    });

    proc.on("close", (code) => {
      console.log(`üîç [DEBUG] Python process exited with code ${code}`);
      if (code !== 0) {
        console.error(`‚ùå [ERROR] Python pipeline failed with code ${code}`);
        console.error(`‚ùå [ERROR] Error output: ${errorOutput}`);
        return reject(
          new Error(`Python exited with code ${code}: ${errorOutput}`)
        );
      }
      try {
        const result = JSON.parse(output);
        // console.log(`üîç [DEBUG] Python pipeline result:`, result);
        resolve(result);
      } catch (err) {
        console.error(
          `‚ùå [ERROR] Failed to parse Python output: ${err.message}`
        );
        console.error(`‚ùå [ERROR] Raw output: ${output}`);
        reject(new Error("Invalid JSON from Python: " + err.message));
      }
    });
  });
}

async function prepareSummaryData(rid) {
  console.log(`üîç [DEBUG] Preparing summary data for report ${rid}`);

  // Get categories from comments_settings table, not main table
  const rows = await db.query(
    `SELECT c.text, cs.value as categories 
     FROM comments c
     LEFT JOIN comments_settings cs ON c.cid = cs.cid AND cs.name = 'categories'
     WHERE c.rid = $1`,
    [rid]
  );

  console.log(`üîç [DEBUG] Found ${rows.length} comments for report ${rid}`);

  const themeCounts = {};
  const commentsByTheme = {};
  let commentsWithCategories = 0;
  let totalCategories = 0;

  for (const row of rows) {
    if (!row.categories) {
      console.log(
        `üîç [DEBUG] Comment has no categories: "${row.text.substring(
          0,
          50
        )}..."`
      );
      continue;
    }

    commentsWithCategories++;
    let categories = [];

    try {
      // Try to parse as JSON first
      if (typeof row.categories === "string") {
        categories = JSON.parse(row.categories);
      } else if (Array.isArray(row.categories)) {
        categories = row.categories;
      } else {
        // Fallback: try comma-separated string
        categories = row.categories
          .split(",")
          .map((t) => t.trim())
          .filter(Boolean);
      }
    } catch (err) {
      console.warn(`‚ö†Ô∏è Failed to parse categories for comment: ${err.message}`);
      // Fallback: try comma-separated string
      categories = row.categories
        .split(",")
        .map((t) => t.trim())
        .filter(Boolean);
    }

    // console.log(`üîç [DEBUG] Comment categories: [${categories.join(', ')}] for text: "${row.text.substring(0, 50)}..."`);

    for (const category of categories) {
      themeCounts[category] = (themeCounts[category] || 0) + 1;
      totalCategories++;
      if (!commentsByTheme[category]) {
        commentsByTheme[category] = [];
      }
      commentsByTheme[category].push(row.text);
    }
  }

  console.log(
    `üîç [DEBUG] Summary stats: ${commentsWithCategories}/${rows.length} comments have categories, ${totalCategories} total category occurrences`
  );
  console.log(`üîç [DEBUG] Category counts:`, themeCounts);
  console.log(`üîç [DEBUG] Comments by category:`, Object.keys(commentsByTheme));

  const data = {
    themes: themeCounts,
    comments_by_theme: commentsByTheme,
  };

    const sanitizedSummaryFileName = sanitizeFilePath(`summary_input_${rid}.json`);
    if (!sanitizedSummaryFileName) {
      throw new Error("Invalid file name");
    }
    
    const tempPath = path.resolve(
      global.__basedir,
      "tmp",
      sanitizedSummaryFileName
    );
    
    // Ensure we're writing to the tmp directory
    if (!tempPath.startsWith(path.resolve(global.__basedir, "tmp"))) {
      throw new Error("Invalid file path");
    }
    
    await fs.writeFile(tempPath, JSON.stringify(data, null, 2), "utf-8");
    console.log(`üîç [DEBUG] Summary data written to: ${tempPath}`);
    return tempPath;
}
