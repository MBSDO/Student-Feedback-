console.log("üîß report.mjs is executing...");

import express from "express";
import { db } from "./db.mjs";
import path from "path";
import fs from "fs/promises";
import fsSync from "fs";
import crypto from "crypto";
import { spawn } from "child_process";
import { fileURLToPath } from "url";
import { parse } from "csv-parse/sync";
import { Comment } from "./comment.mjs";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ‚úÖ Global in-memory progress tracker
const progressMap = new Map();

export class Report {
  constructor() {
    this.tableName = "reports";
    this.primaryKey = "rid";
    this.rid = null;
    this.uid = null;
    this.name = "";
    this.updated = null;
    this.exists = false;
  }

  async Create(uid) {
    const result = await db.query(
      `INSERT INTO ${this.tableName} (uid, name, updated)
       VALUES ($1, $2, NOW())
       RETURNING rid`,
      [uid, this.name || "Untitled Report"]
    );
    await this.Get(result[0].rid);
  }

  async Get(rid) {
    const rows = await db.query(
      `SELECT * FROM ${this.tableName} WHERE ${this.primaryKey} = $1 LIMIT 1`,
      [rid]
    );
    if (rows.length === 0) return false;
    Object.assign(this, rows[0]);
    this.exists = true;
    return true;
  }

  async SaveSettings(settings) {
    for (const key in settings) {
      await db.query(
        `INSERT INTO reports_settings (rid, name, value)
         VALUES ($1, $2, $3)
         ON CONFLICT (rid, name) DO UPDATE SET value = EXCLUDED.value`,
        [this.rid, key, settings[key]]
      );
    }
  }

  async SaveSetting(name, value) {
    await this.SaveSettings({ [name]: value });
  }

  async GetSetting(key) {
    const rows = await db.query(
      `SELECT value FROM reports_settings WHERE rid = $1 AND name = $2 LIMIT 1`,
      [this.rid, key]
    );
    return rows[0]?.value || null;
  }
}

export const ReportRouter = express.Router();

ReportRouter.get("/test-health", (req, res) => {
  res.json({ status: "alive" });
});

ReportRouter.get("/list", (req, res, next) => {
  if (req.accepts("html")) {
    return res.sendFile(
      path.resolve(global.__basedir, "public/pages/reports.html")
    );
  }
  return next();
});

ReportRouter.get("/list/data", async (req, res) => {
  try {
    const uid = req.session?.user?.uid || 1;
    const rows = await db.query(
      `SELECT rid, name, updated FROM reports WHERE uid = $1 ORDER BY updated DESC`,
      [uid]
    );
    const commentCounts = await db.query(
      `SELECT rid, COUNT(*) AS comments_count FROM comments GROUP BY rid`
    );
    const countMap = Object.fromEntries(
      commentCounts.map((row) => [row.rid, parseInt(row.comments_count)])
    );
    const result = rows.map((row) => ({
      ...row,
      comments_count: countMap[row.rid] || 0,
    }));
    res.json(result);
  } catch (err) {
    console.error("‚ùå Failed to fetch report list:", err);
    res.status(500).json({ error: "Internal server error" });
  }
});

ReportRouter.get("/create", async (req, res) => {
  try {
    const uid = req.session?.user?.uid || 1;
    const professor = req.query.professor?.trim() || "Unknown Professor";
    const course = req.query.course?.trim() || "Untitled Course";
    const report = new Report();
    report.name = `${professor} ‚Äì ${course}`;
    await report.Create(uid);
    res.json({
      rid: report.rid,
      name: report.name,
      updated: report.updated,
      comments_count: 0,
    });
  } catch (err) {
    res.status(500).json({ error: "Failed to create report" });
  }
});

// ‚úÖ New: Progress polling endpoint
ReportRouter.get("/progress/:rid", (req, res) => {
  const rid = req.params.rid;
  const progress = progressMap.get(rid);
  if (progress) {
    res.json(progress);
  } else {
    res.json({ percent: 0, message: "Initializing..." });
  }
});

ReportRouter.all("/:rid/view", async (req, res) => {
  try {
    const report = new Report();
    const found = await report.Get(req.params.rid);
    if (!found) return res.status(404).json({ error: "Report not found" });

    // Fetch the summary text from settings
    const summary_text = await report.GetSetting("summary_text");
    const theme_summary_json = await report.GetSetting("themes_summary_json");

    // Add summary_text to the response
    const reportData = {
      ...report,
      summary_text,
      theme_summary: JSON.parse(theme_summary_json || "{}"),
    };

    res.json(reportData);
  } catch (err) {
    res.status(500).json({ error: "Internal server error" });
  }
});

ReportRouter.get("/:rid/comments", async (req, res) => {
  try {
    const rid = parseInt(req.params.rid);
    const rows = await db.query(
      `SELECT * FROM comments WHERE rid = $1 ORDER BY cid ASC`,
      [rid]
    );
    res.json(rows);
  } catch (err) {
    res.status(500).json({ error: "Internal server error" });
  }
});

ReportRouter.post("/upload", async (req, res) => {
  try {
    if (!req.session.user) {
      return res
        .status(403)
        .sendFile(path.resolve(global.__basedir, "public/pages/403.html"));
    }

    const {
      professor,
      course_code,
      semester,
      csv_text,
      codebook_json,
      summary_text,
      recoded_output_json,
    } = req.body;

    const records = parse(csv_text, {
      delimiter: "\t",
      skip_empty_lines: true,
      relax_quotes: true,
      quote: '"',
      escape: '"',
      relax_column_count: true,
    });

    const comments = records
      .slice(1)
      .map((row) => row[3]?.trim())
      .filter((text) => text && !text.startsWith("Question:"));

    const uid = req.session.user.uid;
    const csv_hash = crypto.createHash("sha256").update(csv_text).digest("hex");

    const nameParts = professor.trim().split(" ");
    const first = nameParts[0] || "Unknown";
    const last = nameParts.length > 1 ? nameParts.slice(1).join(" ") : "(none)";

    let [result] = await db.query(
      "SELECT pid FROM professors WHERE first_name = $1 AND last_name = $2",
      [first, last]
    );

    let pid = result?.pid;
    if (!pid) {
      const insert = await db.query(
        "INSERT INTO professors (first_name, last_name) VALUES ($1, $2) RETURNING pid",
        [first, last]
      );
      pid = insert[0].pid;
    }

    const existing = await db.query(
      `SELECT rid FROM reports WHERE pid = $1 AND course_code = $2 AND semester = $3 AND csv_hash = $4 AND uid = $5 LIMIT 1`,
      [pid, course_code, semester, csv_hash, uid]
    );

    let report;
    if (existing.length > 0) {
      report = new Report();
      await report.Get(existing[0].rid);
      const summary = await report.GetSetting("summary_text");
      const recoded = await report.GetSetting("recoded_output_json");
      const codebook = await report.GetSetting("codebook_json");
      return res.json({ report, summary, recoded, codebook, cached: true });
    }

    report = new Report();
    report.name = `${professor} ‚Äì ${course_code} (${semester})`;
    await report.Create(uid);

    // ‚úÖ Progress update: saving comments
    progressMap.set(report.rid, { percent: 10, message: "Saving comments..." });

    for (const text of comments) {
      const comment = new Comment();
      try {
        await comment.Create(report.rid, text);
      } catch (err) {
        console.warn("‚ö†Ô∏è Failed to insert comment:", err.message);
      }
    }

    // ‚úÖ Progress update: writing metadata
    progressMap.set(report.rid, {
      percent: 30,
      message: "Writing metadata...",
    });

    await db.query(
      `UPDATE reports SET pid = $1, course_code = $2, semester = $3, csv_hash = $4 WHERE rid = $5`,
      [pid, course_code, semester, csv_hash, report.rid]
    );

    // ‚úÖ Progress update: extracting themes
    progressMap.set(report.rid, {
      percent: 40,
      message: "Extracting themes...",
    });

    if (!fsSync.existsSync(path.resolve(global.__basedir, "tmp"))) {
      fsSync.mkdirSync(path.resolve(global.__basedir, "tmp"));
    }

    const tempPath = path.resolve(
      global.__basedir,
      `tmp/report_${report.rid}.csv`
    );
    await fs.writeFile(tempPath, csv_text);

    // ‚úÖ NEW: Process themes for all comments before summary generation
    console.log(
      `ÔøΩÔøΩ [DEBUG] Processing categories for all comments in report ${report.rid}`
    );
    const commentRows = await db.query(
      "SELECT cid, text FROM comments WHERE rid = $1",
      [report.rid]
    );

    let processedCount = 0;
    let failedCount = 0;

    for (const row of commentRows) {
      try {
        const comment = new Comment();
        await comment.Get(row.cid);
        await comment.Process(); // This will extract and save categories
        // console.log(`üîç [DEBUG] Processed categories for comment ${row.cid}: ${comment.categories || 'none'}`);
        processedCount++;
      } catch (err) {
        console.warn(
          `‚ö†Ô∏è Failed to process categories for comment ${row.cid}:`,
          err.message
        );
        failedCount++;
      }
    }

    console.log(
      `üîç [DEBUG] Category processing complete: ${processedCount} successful, ${failedCount} failed`
    );

    const themeCounts = await summarizeReportThemes(report.rid);
    const themeSummaryPath = path.resolve(
      global.__basedir,
      `tmp/themes_summary_${report.rid}.json`
    );
    await fs.writeFile(
      themeSummaryPath,
      JSON.stringify(themeCounts, null, 2),
      "utf-8"
    );

    // ‚úÖ Progress update: generating summary and GPT tags
    progressMap.set(report.rid, {
      percent: 60,
      message: "Generating summary and tags...",
    });

    const jsonPath = await prepareSummaryData(report.rid);
    const { summary, top_5_themes, related_comments } =
      await runPythonCodebookPipeline(jsonPath, report.rid);

    const recodedPath = path.resolve(global.__basedir, "recoded_comments.json");
    let recoded = [];

    if (fsSync.existsSync(recodedPath)) {
      const content = fsSync.readFileSync(recodedPath, "utf-8");
      recoded = JSON.parse(content);

      for (const entry of recoded) {
        if (!entry.cid || !Array.isArray(entry.categories)) continue;

        await db.query(`UPDATE comments SET categories = $1 WHERE cid = $2`, [
          JSON.stringify(entry.categories), // Convert to JSON string
          entry.cid,
        ]);
      }
    }

    // ‚úÖ Progress update: finalizing
    progressMap.set(report.rid, { percent: 90, message: "Finalizing..." });

    const settingsToSave = {};
    if (summary) {
      console.log(
        `üîç [DEBUG] Saving summary for report ${report.rid}:`,
        summary.substring(0, 200) + "..."
      );
      settingsToSave.summary_text = summary;
    } else {
      console.log(`‚ö†Ô∏è [WARNING] No summary generated for report ${report.rid}`);
    }
    if (recoded_output_json)
      settingsToSave.recoded_output_json = recoded_output_json;
    if (codebook_json) settingsToSave.codebook_json = codebook_json;

    await report.SaveSettings(settingsToSave);
    await report.SaveSetting(
      "themes_summary_json",
      JSON.stringify(themeCounts)
    );

    // ‚úÖ Done
    progressMap.set(report.rid, { percent: 100, message: "Complete" });

    res.json({
      report,
      summary,
      recoded,
      codebook: JSON.parse(codebook_json || "{}"),
      theme_summary: themeCounts,
      cached: false,
    });
  } catch (err) {
    console.error("‚ùå Upload failed:", err);
    res.status(500).json({ error: err.message });
  }
});

ReportRouter.post("/:rid/delete", async (req, res) => {
  try {
    const rid = parseInt(req.params.rid);
    await db.query(`DELETE FROM comments WHERE rid = $1`, [rid]);
    await db.query(`DELETE FROM reports_settings WHERE rid = $1`, [rid]);
    await db.query(`DELETE FROM reports WHERE rid = $1`, [rid]);
    res.json({ success: true });
  } catch (err) {
    console.error("Failed to delete report:", err);
    res.status(500).json({ error: "Failed to delete report" });
  }
});

ReportRouter.get("/:rid", (req, res) => {
  res.sendFile(path.resolve(global.__basedir, "public/pages/report.html"));
});

export async function summarizeReportThemes(rid) {
  console.log(`üîç [DEBUG] Summarizing categories for report ${rid}`);
  const rows = await db.query(
    "SELECT categories FROM comments WHERE rid = $1",
    [rid]
  );
  console.log(
    `üîç [DEBUG] Found ${rows.length} comments for category summarization`
  );

  const themeCounts = {};
  let commentsWithCategories = 0;

  for (const row of rows) {
    if (!row.categories) {
      // console.log(`üîç [DEBUG] Comment has no categories for summarization`);
      continue;
    }

    commentsWithCategories++;
    let categories = [];

    try {
      // Try to parse as JSON first
      if (typeof row.categories === "string") {
        categories = JSON.parse(row.categories);
      } else if (Array.isArray(row.categories)) {
        categories = row.categories;
      } else {
        // Fallback: try comma-separated string
        categories = row.categories
          .split(",")
          .map((t) => t.trim())
          .filter(Boolean);
      }
    } catch (err) {
      console.warn(`‚ö†Ô∏è Failed to parse categories for comment: ${err.message}`);
      // Fallback: try comma-separated string
      categories = row.categories
        .split(",")
        .map((t) => t.trim())
        .filter(Boolean);
    }

    // console.log(`üîç [DEBUG] Processing categories for summarization: [${categories.join(', ')}]`);

    for (const category of categories) {
      themeCounts[category] = (themeCounts[category] || 0) + 1;
    }
  }

  console.log(
    `üîç [DEBUG] Category summarization complete: ${commentsWithCategories}/${rows.length} comments had categories`
  );
  console.log(`üîç [DEBUG] Final category counts:`, themeCounts);

  return themeCounts;
}

function runPythonCodebookPipeline(jsonPath, reportId) {
  return new Promise((resolve, reject) => {
    console.log(
      `üîç [DEBUG] Starting Python pipeline for report ${reportId} with data from ${jsonPath}`
    );

    // ‚úÖ Default to system python3 (for Render)
    let pythonPath = "python3";

    // ‚úÖ Use local venv python if it exists
    const localVenvPath = path.resolve(
      __dirname,
      "..",
      "venv",
      process.platform === "win32" ? "Scripts/python.exe" : "bin/python3"
    );

    if (fsSync.existsSync(localVenvPath)) {
      pythonPath = localVenvPath;
      console.log(`üîç [DEBUG] Using local venv python: ${pythonPath}`);
    } else {
      console.log(`üîç [DEBUG] Using system python: ${pythonPath}`);
    }

    const proc = spawn(pythonPath, [
      "codebook_pipeline.py",
      jsonPath,
      String(reportId),
    ]);

    let output = "";
    let errorOutput = "";

    proc.stdout.on("data", (chunk) => {
      const data = chunk.toString();
      output += data;
      // console.log(`üîç [DEBUG] Python stdout: ${data}`);
    });

    proc.stderr.on("data", (err) => {
      const error = err.toString();
      errorOutput += error;
      console.error("üîç [DEBUG] Python stderr:", error);
    });

    proc.on("close", (code) => {
      console.log(`üîç [DEBUG] Python process exited with code ${code}`);
      if (code !== 0) {
        console.error(`‚ùå [ERROR] Python pipeline failed with code ${code}`);
        console.error(`‚ùå [ERROR] Error output: ${errorOutput}`);
        return reject(
          new Error(`Python exited with code ${code}: ${errorOutput}`)
        );
      }
      try {
        const result = JSON.parse(output);
        // console.log(`üîç [DEBUG] Python pipeline result:`, result);
        resolve(result);
      } catch (err) {
        console.error(
          `‚ùå [ERROR] Failed to parse Python output: ${err.message}`
        );
        console.error(`‚ùå [ERROR] Raw output: ${output}`);
        reject(new Error("Invalid JSON from Python: " + err.message));
      }
    });
  });
}

async function prepareSummaryData(rid) {
  console.log(`üîç [DEBUG] Preparing summary data for report ${rid}`);

  const rows = await db.query(
    "SELECT text, categories FROM comments WHERE rid = $1",
    [rid]
  );

  console.log(`üîç [DEBUG] Found ${rows.length} comments for report ${rid}`);

  const themeCounts = {};
  const commentsByTheme = {};
  let commentsWithCategories = 0;
  let totalCategories = 0;

  for (const row of rows) {
    if (!row.categories) {
      console.log(
        `üîç [DEBUG] Comment has no categories: "${row.text.substring(
          0,
          50
        )}..."`
      );
      continue;
    }

    commentsWithCategories++;
    let categories = [];

    try {
      // Try to parse as JSON first
      if (typeof row.categories === "string") {
        categories = JSON.parse(row.categories);
      } else if (Array.isArray(row.categories)) {
        categories = row.categories;
      } else {
        // Fallback: try comma-separated string
        categories = row.categories
          .split(",")
          .map((t) => t.trim())
          .filter(Boolean);
      }
    } catch (err) {
      console.warn(`‚ö†Ô∏è Failed to parse categories for comment: ${err.message}`);
      // Fallback: try comma-separated string
      categories = row.categories
        .split(",")
        .map((t) => t.trim())
        .filter(Boolean);
    }

    // console.log(`üîç [DEBUG] Comment categories: [${categories.join(', ')}] for text: "${row.text.substring(0, 50)}..."`);

    for (const category of categories) {
      themeCounts[category] = (themeCounts[category] || 0) + 1;
      totalCategories++;
      if (!commentsByTheme[category]) {
        commentsByTheme[category] = [];
      }
      commentsByTheme[category].push(row.text);
    }
  }

  console.log(
    `üîç [DEBUG] Summary stats: ${commentsWithCategories}/${rows.length} comments have categories, ${totalCategories} total category occurrences`
  );
  console.log(`üîç [DEBUG] Category counts:`, themeCounts);
  console.log(`üîç [DEBUG] Comments by category:`, Object.keys(commentsByTheme));

  const data = {
    themes: themeCounts,
    comments_by_theme: commentsByTheme,
  };

  const tempPath = path.resolve(
    global.__basedir,
    "tmp",
    `summary_input_${rid}.json`
  );
  await fs.writeFile(tempPath, JSON.stringify(data, null, 2), "utf-8");
  console.log(`üîç [DEBUG] Summary data written to: ${tempPath}`);
  return tempPath;
}
