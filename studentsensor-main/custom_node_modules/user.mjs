console.log('Loading User Module');
import { DBEntity } from './dbentity.mjs';
import bcrypt from 'bcrypt';
import { db } from './db.mjs';

export class User extends DBEntity {
    constructor() {
        super('users', 'uid');
    }
    async Can(user, verb) {
        if (await CheckRole(user, 'author_editor')) return true;
        if(verb=='list') return super.Can(user, 'edit');
        return super.Can(user, verb);
    }
    async Create() {
        await super.Create();
        await this.SaveSetting('credits', 1000, true);
        return await new Promise((resolve, reject) => {
            resolve(this);
        });
    }
    Mask() {
        if (this.hash !== undefined) delete this.hash;
    }
    async HashPassword(password) {
        let self = this;
        return new Promise((resolve) => {
            let saltRounds = 10;
            bcrypt.hash(password, saltRounds, function (err, hash) {
                self.SaveSetting('hash', hash);
                resolve(true);
            });
        });
    }
    async CheckPassword(password) {
        return new Promise((resolve) => {
            bcrypt.compare(password, this.hash, function (err, result) {
                resolve(result);
            });
        });
    }
    async CreditsAvailable(amount) {
        let userCredits = await this.GetSetting('credits');
        if (userCredits == undefined) userCredits = 0;
        userCredits = parseInt(userCredits);
        if (userCredits > amount) return true;
        return false;
    }
    async DeductCredits(amount) {
        // Total Used
        let usedCredits = parseInt(await this.GetSetting('credits_used'));
        if (usedCredits == undefined || isNaN(usedCredits)) usedCredits = 0;
        usedCredits += parseInt(amount);
        await this.SaveSetting('credits_used', usedCredits, true);
        // Remaining
        let userCredits = parseInt(await this.GetSetting('credits'));
        if (userCredits == undefined || isNaN(userCredits)) userCredits = 0;
        userCredits += -parseInt(amount);
        await this.SaveSetting('credits', userCredits, true);
        return userCredits;
    }
}
export async function CheckRole(user, role) {
    if(user===undefined) return false;
    //console.log(user);
    role = 'is_' + role;
    if (user.settings !== undefined && (user.settings['is_' + role] === '1')) return true;
    const results = await db.query('SELECT uid FROM users_settings WHERE uid = $1 AND name = $2 AND value = $3 LIMIT 1', [user.uid, role, '1']);
    //console.log(results.length);
    if (results.length > 0) {
        return true;
    }
    return false;
}
export function Can(user, verb, entity) {
    return entity.Can(user, verb);
}